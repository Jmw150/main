#!/home/jordan/backup/scripts/Mars4_5.jar nc
# this file is a test bed and storage place for mips functions
# go to the main
    j       main                # thanks mars...
# print_str(string $a0)
# prints a string when given a register of it
    li      $v0, 4              # print str
# end print_str
# $v0 = read_int()
# end read_int
# $f0 = read_float()
# end read_float
# $f0 = read_double()
# end read_double
# read_string(a0=buffer,a1=length)
# end read_string
# v0 = read_char()
# end read_char
# print_char(a0)
# end print_char
# return()
# return to previous function call, (or $ra location)
    jr      $ra                 # jump back to previous function
# end return
    jr      $ra                 # jump back to previous function
# exit program
    li      $v0,10              # v0 is the syscall pointer
    syscall                     # syscall 10 == exit program
# end exit
    li      $v0,10              # v0 is the syscall pointer
    syscall                     # syscall 10 == exit program
# print_int($a0)
#.macro  print_int(%a0)
#    move    $a0, %a0
# end print_int
#   print_str ("test1") #"test1" will be labeled with name "myLabel_M0"
#   print_str ("test2") #"test2" will be labeled with name "myLabel_M1"
# generic looping mechanism
    #print an integer
    #printing 1 to 10:
main:                           #($a0 = argc, $a1 = argv), 4*n($a1) = nth command
#    lw      $a0, 4($a1)         # get first command line argv
#.include "test.asm" #mov $0, $0
    #addi    $t0, $0, 5
    #print_int($t0)
    #move    $a0, $t0
    #li      $v0, 1
    #syscall
# functions made:
# exit, return, read str, print str, prompt for str, say hello, main(argc,args), strlen
# functions still to implement
# tag_exists, open file, read from file, print to file, close file, read char file, read char
# $s0 = read_str()
# reads a string (max 1024 bytes)
string_space: .space 1024       # set aside 1024 bytes for the string.
    .text                       ## Assembly language instructions go in text segment
    la      $a0, string_space   # pointer of string
    li      $a1, 1024           # space allocated on str pointer
 #   string  = 8                 # apparently this is legal (but only in spim)
    li      $v0, 8              # 'read a string' code
    add     $s0,$a0,$0          # save in standard place
# end read_str
# prompt_for_str(), prompt user to input message
# say_hello_world(), say "Hello, World!\n"
hello_world:.asciiz "Hello, World!\n" ## how to store strings in a file
    li      $v0, 4              # system call code for printing string = 4
    la      $a0, hello_world    # load address of string to be printed into $a0
    syscall                     # call operating system to perform operation
                                # specified in $v0
                                # syscall takes its arguments from $a0, $a1, ...
    jr      $ra                 # return to main
# Standard startup code.  Invoke the routine "main" with arguments:
#   main(argc, argv, envp)
#
    lw      $a0 0($sp)          # argc
    addiu   $a1 $sp 4           # argv
    addiu   $a2 $a1 4           # envp
    li      $t0, 0              # initialize the count to zero
    lbu     $t1, 0($a0)         # load the next character into t1
    beqz    $t1, return         # check for the null character
    addi    $a0, $a0, 1         # increment the string pointer
    addi    $t0, $t0, 1         # increment the count
    j       strlen_loop         # return to the top of the loop
    lw      $t0, 0($a0)         # load the first array value into t0
    li      $t1, 1              # initialize the counter to one
    beq     $t1, $a1, return    # exit if we reach the end of the array
    addi    $a0, $a0, 4         # increment the pointer by one word
    addi    $t1, $t1, 1         # increment the loop counter
    lw      $t2, 0($a0)         # store the next array value into t2
    move    $t0, $t2            # found a new maximum, store it in t0
    j       max_loop            # repeat the loop
# Description: Program accepts numbers from user and adds them together, terminates at input of 0
# Input: User enter numbers
# Output: Sum of numbers entered
################# Data segment #####################
################# Code segment #####################
    add     $s1, $zero, $zero   # Initialize $s1 to zero - reserved for our total sum
sum_Loop: li $v0, 4              # Load system call to print input string
    la      $a0, sum_inputString# Load input string for printing
    li      $v0, 5              # Load system call to read number from user
    add     $s1, $s1,   $v0     # Add number to total sum
    bne     $v0, $zero, sum_Loop# Loop if last number wasn't 0
    li      $v0, 4              # Load system call to print output string
    la      $a0, sum_outputString # Load output string for printing
    li      $v0, 1              # Load system call to print string
    add     $a0, $s1, $zero     # Load sum into $a0 for printing
    li      $v0, 4              # Load system call to print output string
    la      $a0, sum_newline    # Load output string for newline
# Description: Displays the moves needed to solve the puzzle of the towers of Hanoi
# Input: Number of rings
# Output: Steps for solving the problem
################# Data segment #####################
################# Code segment #####################
# Variable Key:
# $a0 = n
# $a1 = start
# $a2 = finish
# $a3 = extra
    li      $v0, 4              # Load number for system call for printing string
    la      $a0, hanoi_requestInput # Load string
    li      $v0, 5              # Load number for system call for reading number in
    addi    $a0, $v0,   0       # Put user number in $a0
    addi    $a1, $zero, 1       # Put 1 in start
    addi    $a2, $zero, 2       # Put 2 in finish
    addi    $a3, $zero, 3       # Put 3 in extra
hanoi_r: addi $sp, $sp, -20     # Make room in stack
    sw      $ra, 16($sp)        # Store returning address
    sw      $a0, 12($sp)        # Store n
    sw      $a1, 8($sp)         # Store start
    sw      $a2, 4($sp)         # Store finish
    sw      $a3, 0($sp)         # Store extra
    slti    $t0, $a0,   1       # Test base case
    beq     $t0, $zero, hanoi_Skip # As long as n > 0, call recursively
    addi    $sp, $sp,   20      # If n = 0, adjust stack pointer and begin backtracing
hanoi_Skip: addi $a0, $a0, -1   # Decrement n
    add     $t0, $a2, $zero     # Temp holder for $a1 for swapping proceedure next
    add     $a2, $a3, $zero     # Swap
    add     $a3, $t0, $zero     # Swap
    jal     hanoi_r             # Recursive call
    lw      $a3, 0($sp)         # Load Extra
    lw      $a2, 4($sp)         # Load Finish
    lw      $a1, 8($sp)         # Load start
    lw      $a0, 12($sp)        # Load n
    lw      $ra, 16($sp)        # Load returning address
    addi    $sp, $sp, 20        # Adjust stack pointer
    add     $t0, $a0, $zero     # Back up n temporarily
    li      $v0, 4              # Load number for system call for printing string
    la      $a0, hanoi_moveDisk # Load string
    li      $v0, 1              # Load number for system call for print number
    add     $a0, $t0, $zero     # Move $a0 for printing
    li      $v0, 4              # Load number for system call for printing string
    la      $a0, hanoi_fromPeg  # Load string
    li      $v0, 1              # Load number for system call for print number
    add     $a0, $zero, $a1     # Move $a1 for printing
    li      $v0, 4              # Load number for system call for printing string
    la      $a0, hanoi_toPeg    # Load string
    li      $v0, 1              # Load number for system call for print number
    add     $a0, $zero, $a2     # Move $a2 for printing
    li      $v0, 4              # Load number for system call for printing string
    la      $a0, hanoi_newline  # Load string
    add     $a0, $t0, $zero     # recover n
    addi    $a0, $a0, -1        # Decrement n
    add     $t0, $a1, $zero     # Temp holder for $a1 for swapping proceedure next
    add     $a1, $a3, $zero     # Swap
    add     $a3, $t0, $zero     # Swap
    j       hanoi_r             # Recursive call
# 4. Find the shortest sequence of MIPS instructions that extracts the 18-bit field in locations 5 through 22 (bit position 31 is the MSB) from register \$t3 and places it in register \$t0. Hint: Use shift instructions. \\
    # extract 5-22 bit postion from t3
    sll     $t0, $t3, 10        # take off top,    32 = 22+10
    srl     $t0, $t0, 15        # take off bottom, -5 = 10-15
# hw5.6
# if ((a < b) && (c == 0))
#   d = 1;
# a,  b,  c,  d,  i,  x
# t1, t2, t3, t4, s0, s1
#
if:                             #if ((a < b) && (c == 0)) d = 1;
    slt     $t0, $t1, $t2       # a <  b
    seq     $t8, $t1, $0        # c == 0
    and     $t0, $t0, $t8       # (a <  b) && (c == 0)
    beq     $t0, $0, skip       # if ((a < b) && (c == 0))
    addi    $t4, $0, 1          #   d = 1;
# hw5.1
# translate some c code to mips
# for (i = 0; i < x; i=i+1)
#    y = y + i;
# $s0 = i, $s1 = x, $s2 = y
# required: use slt
for:                            # for (i = 0; i < x; i=i+1) y = y + i;
    add     $s0, $0, $0         # i=0
    slt     $t0, $s0, $s1       # (i < x) ? 1 : 0
    beq     $t0, $0, endfor     # exit if (i < x)
    add     $s2, $s2, $s0       # y = y + i
    addi    $s0, $s0, 1         # i = i + 1
# 3. Translate the following MIPS code to C. Assume that the variables f, g, h, i, and j are assigned to registers \$s0, \$s1, \$s2, \$s3, and \$s4, respectively. Assume that the base address of the arrays A and B are in registers \$s6 and \$s7, respectively. \\
### I have no idea how floating point works yet
# print_float($f12) 
#.macro print_float %f12
#    move    $f12, %f12 # su
#    li      $v0, 2
#    syscall
#.end_macro
# end print_float
## print_double($f12) 
#.macro print_double
#    li      $v0, 3
#    syscall
#.end_macro
# end print_double
###
