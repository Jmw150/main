\iffalse
// c precompiler stuff
#define cnote \
\begin{lstlisting}[ \
  mathescape, \
  columns=fullflexible, \
  basicstyle=\fontfamily{lmvtt}\selectfont, \
] 

#define endcnote \end{lstlisting}
\fi

\documentclass{article} 
\usepackage{amsthm} % writing proofs
\usepackage{amsfonts} % for blackboard bold charactes like Z R
\usepackage{amssymb} % came with intermediate value thrm
\usepackage[fleqn]{amsmath} % for arguments vertically underneath like lim, piecwise functions, equality arrays
\setlength{\mathindent}{0in} %neutralizes equation indentation
\usepackage{listings} % more literal, makes hw easier
\setlength{\parindent}{0in} %neutralizes annoying paragraph indent
\usepackage{mathtools} % for floor and ceiling functions / macros
\usepackage{nccmath} % for centering equations with ceqn
\usepackage{tkz-euclide} % geometry
\usetkzobj{all} % include all objects of tkz

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\f}{\frac}
\newcommand{\ra}{\rightarrow}
\newcommand{\rla}{\leftrightarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\bb}{\mathbb}

%\renewcommand{\qedsymbol}{$\blacksquare$}
\renewcommand{\qedsymbol}{$\dashv$}

\begin{document}

Jordan Winkler
Computer Architecture
Mon Apr  1 23:43:45 EDT 2019
hw8: 4.{1,2,3.1}


1) Do Exercise 4.1 (all parts) on page 357 of the textbook. 

4.1 Consider the following instruction:
Instruction: AND Rd,Rs,Rt
Interpretation: Reg[Rd] = Reg[Rs] AND Reg[Rt]

4.1.1 [5] <§4.1> What are the values of control signals generated by the control in Figure 4.2 for the above instruction?

ALU operation (AND, 24_16)
Top Mux (default PC+4)
Middle Mux (ALU)
Bottom Mux (second register, rt)
Branch (no, 0)
MEM READ (no, 0)
MEM WRITE (no, 0)

4.1.2 [5] <§4.1> Which resources (blocks) perform a useful function for this instruction?

program counter, instruction memory, registers, ALU

4.1.3 [10] <§4.1> Which resources (blocks) produce outputs, but their outputs are not used for this instruction? Which resources produce no outputs for this instruction?

produce unused output:
ALU (0/1) signal is not used for the branch signal, since control did not send a signal to branch.

No outputs:
memread, memwrite


2) Do Exercise 4.2 (all parts) on page 357 of the textbook.

4.2 The basic single-cycle MIPS implementation in Figure 4.2 can only implement some instructions. New instructions can be added to an existing Instruction Set Architecture (ISA), but the decision whether or not to do that depends, among other things, on the cost and complexity the proposed addition introduces into the processor datapath and control. Th e fi rst three problems in this exercise refer to the new instruction:

Instruction: LWI Rt,Rd(Rs)
Interpretation: Reg[Rt] = Mem[Reg[Rd]+Reg[Rs]]

4.2.1 [10] <§4.1> Which existing blocks (if any) can be used for this instruction?

PC, instruction memory, registers, data memory, ALU

4.2.2 [10] <§4.1> Which new functional blocks (if any) do we need for this instruction?

Nothing needed to be added to the structure in figure 4.2. Data memory is a new function block from problem 4.1.2.

4.2.3 [10] <§4.1> What new signals do we need (if any) from the control unit to support this instruction?

No new signal connections are needed to perform LWI.


3) Do Exercise 4.3 (just part 1) on page 358 of the textbook.

4.3 When processor designers consider a possible improvement to the processor datapath, the decision usually depends on the cost/performance trade-off. In the following three problems, assume that we are starting with a datapath from Figure 4.2, where I-Mem, Add, Mux, ALU, Regs, D-Mem, and Control blocks have latencies of 400 ps, 100 ps, 30 ps, 120 ps, 200 ps, 350 ps, and 100 ps, respectively, and costs of 1000, 30, 10, 100, 200, 2000, and 500, respectively. Consider the addition of a multiplier to the ALU. This addition will add 300 ps to the latency of the ALU and will add a cost of 600 to the ALU. The result will be 5\% fewer instructions executed since we will no longer need to emulate the MUL instruction.

4.3.1 [10] <§4.1> What is the clock cycle time with and without this improvement?

In this model, add happens while I-mem is being read to Control and must be buffered. Register can send output while waiting for control, since the mux will filter the results anyway. Then it is sequential.

clock_cycle_time.no_mult = I-Mem + Regs + Mux + ALU + D-Mem + Mux + Regs =  400ps + 200ps + 30ps + 120ps + 350ps + 30ps + 30ps = 1160ps

clock_cycle_time.mult = I-Mem + Regs + Mux + ALU + 300ps + D-Mem + Mux + Regs = 1160ps + 300ps = 1460ps

\end{document}