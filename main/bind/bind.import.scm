;;;; bind.import.scm - GENERATED BY CHICKEN 5.0.0 -*- Scheme -*-

(scheme#eval
  '(import-syntax scheme chicken.base chicken.foreign chicken.syntax))
(##core#begin
  (import bind-translator)
  (import (chicken io))
  (import srfi-1)
  (import srfi-13)
  (define emitted-prelude #f)
  (define prelude
    "#define ___fixnum           int\n#define ___number           double\n#define ___bool             int\n#define ___byte             char\n#define ___scheme_value     C_word\n#define ___scheme_pointer   void *\n#define ___blob             void *\n#define ___pointer_vector   void **\n#define ___symbol           char *\n#define ___safe\n#define ___declare(x, y)\n#define ___specialize\n#define ___abstract\n#define ___discard\n#define ___in\n#define ___out\n#define ___inout\n#define ___mutable\n#define ___length(var)\n#define ___pointer\n#define ___u32              C_u32\n#define ___s32              C_s32\n#define ___u64              C_u64\n#define ___s64              C_s64"))
(##core#begin
  (define (bind:read-file f)
    (let ((fname (cond ((string? f) f)
                       ((symbol? f) (symbol->string (strip-syntax f)))
                       (else (syntax-error 'bind-file "invalid filename" f)))))
      (with-input-from-file fname read-string))))
(##sys#register-compiled-module
  'bind
  'bind
  (scheme#list)
  '()
  (scheme#list
    (scheme#cons
      'bind-rename/pattern
      (er-macro-transformer
        (lambda (x r c)
          (if (= 2 (length (cdr x)))
            (apply set-renaming (append (strip-syntax (cdr x)) '(#:regex #t)))
            (syntax-error 'bind-rename "bad number of arguments" x))
          `(,(r 'void)))))
    (scheme#cons
      'bind-rename
      (er-macro-transformer
        (lambda (x r c)
          (if (= 2 (length (cdr x)))
            (apply set-renaming (strip-syntax (cdr x)))
            (syntax-error 'bind-rename "bad number of arguments" x))
          `(,(r 'void)))))
    (scheme#cons
      'bind-options
      (er-macro-transformer
        (lambda (x r c)
          (apply set-bind-options (strip-syntax (cdr x)))
          `(,(r 'void)))))
    (scheme#cons
      'bind-opaque-type
      (er-macro-transformer
        (lambda (x r c) (parse-opaque-type-declaration (cdr x) r))))
    (scheme#cons
      'bind-type
      (er-macro-transformer
        (lambda (x r c) (parse-type-declaration (cdr x) r))))
    (scheme#cons
      'bind-include-path
      (er-macro-transformer
        (lambda (x r c)
          (set! ffi-include-path-list (append (cdr x) ffi-include-path-list))
          `(,(r 'void)))))
    (scheme#cons
      'bind-file*
      (er-macro-transformer
        (lambda (x r c) `(,(r 'bind*) ,@(map bind:read-file (cdr x))))))
    (scheme#cons
      'bind-file
      (er-macro-transformer
        (lambda (x r c) `(,(r 'bind) ,@(map bind:read-file (cdr x))))))
    (scheme#cons
      'bind*
      (er-macro-transformer
        (lambda (x r c)
          (let* ((strs (append (cdr x) '("\n")))
                 (decls (if emitted-prelude strs (cons prelude strs))))
            (set! emitted-prelude #t)
            `(,(r 'begin)
              (,(r 'declare) (foreign-declare ,@decls))
              (,(r 'bind) ,@strs))))))
    (scheme#cons
      'bind
      (er-macro-transformer
        (lambda (x r c)
          (let ((strs (append (cdr x) '("\n"))))
            `(,(r 'begin) ,@(parse-easy-ffi (string-concatenate strs) r)))))))
  (scheme#list))

;; END OF FILE
