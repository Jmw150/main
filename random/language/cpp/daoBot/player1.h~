// player1.h: player 1 agent.
// Author:    <your name>
// Date:	  <date>
// MS Visual C++
#ifndef PLAYER1_H
#define PLAYER1_H

#include "constants.h"
#include "state.h"
#include "player.h"
#include "player2.h"
#include <list>
#include <map>
using namespace std;

// todo: make these local to player
bool validmove(Move move, board game_board);
bool isover(board game_board);
Move randMove(int p);
list<Move> safeSpace(board game_board, int p,int depth);
list<Move> safeSpaceMe(board game_board, int p);
board makeMove(board game_board, Move move);
bool defense(board game_board, int p);

/* 
   graphy

   examines the graph n steps ahead, 
   tries to play as long as possible

   note: might be cool to store the graph
*/
class Player1 : public Player
{
private:
    class data 
    {
        // data: state of game, player move
        private:
        int datSize;
        int stateSize;
        int moveSize;
        public:
        char* stateMove;

        // constructors
        data();                 // default
        data(char* string);     // from a string
        data(const data &obj);  // copy constructor

        char& operator[](int i) {return stateMove[i];}
        void clean();
        bool isclean();
        bool sameState(char* b);
        bool sameMove(char* b);
        bool sameState(const data& b);
        bool sameMove(const data& b);
        bool safe(const data& b);
        bool safe(char* b);

        // converters
        Move move(Move mov);            // statemove <- move
        board state(board bord);        // stateMove <- state
        void player(unsigned short p);  // stateMove <- player
        char* str() {return stateMove;} // str <- stateMove
        char* dat(char* string);        // stateMove <- str
        Move move();                    // move <- stateMove
        board state();                  // state <- stateMove
        
        // getters
        int getDatSize() { return datSize; }
        int getStateSize() { return stateSize; }
        int getMoveSize() { return moveSize; }

        ~data() { delete[] stateMove; } 
    };
        
    data stateMove; // should be persistent
    
    int datSize() { return stateMove.getDatSize(); }
    int stateSize() { return stateMove.getStateSize(); }
    int moveSize() { return stateMove.getMoveSize(); }
public:
	// default left for compatibility
    Move get_move(unsigned short p, board game_board);

    // main process of deciding a move
    Move bot_move(unsigned short p, board game_board);
};

Move Player1::get_move(unsigned short p, board game_board)
{
    Move move;
     
    move.player = p;
    
    if (gettype()) 
    {
        cout << "Enter move (old_x old_y new_x new_y): ";
    	cin >> move.src_x;
    	cin >> move.src_y;
    	cin >> move.dst_x;
    	cin >> move.dst_y;
    }
    else 
    {
        return bot_move(p,game_board);
    }
}

Move Player1::bot_move(unsigned short p, board game_board)
{
    int searchdepth = 0;

    list<Move> moves = safeSpace(game_board,p,searchdepth);

    if (moves.size() == 0) // panic!
        return randMove(p);
    
    // not super picky
    int random = rand() % moves.size();
    list<Move>::iterator iter = moves.begin();
    for (int i = 0 ; i < random ; i++, iter++); 
    return *iter; 
}


Player1::data::data() 
{
    stateSize = XYDIM*XYDIM;
    moveSize = 5; // struct move size
    datSize = stateSize + moveSize; 

    stateMove = new char[datSize+1]; // for safety
    for (int i = 0 ; i < datSize+1 ; i++)
        stateMove[i] = 0;
}
Player1::data::data(char* input)
{
    stateSize = XYDIM*XYDIM;
    moveSize = 5; // struct move size
    datSize = stateSize + moveSize; 

    stateMove = new char[datSize+1]; 
    stateMove[datSize] = 0; // for safety
    for (int i = 0 ; i < datSize ; i++)
        stateMove[i] = input[i];
}
void Player1::data::clean() 
{ 
    for (int i = 0 ; i < datSize ; i++)
        stateMove[i] = 0;
}
bool Player1::data::isclean() 
{ 
    bool clean = 1;
    for (int i = 0 ; i < datSize ; i++)
        if (stateMove[i] != 0)
            clean = 0;
    return clean;
}
bool Player1::data::sameState(char* b) 
{
    bool isSame = 1;
    for (int i = 0 ; i < stateSize ; i++)
        if (stateMove[i] != b[i]) 
            isSame = 0;
    return isSame;
}
bool Player1::data::sameMove(char *b)
{
    bool isSame = 1;
    for (int i = (datSize-moveSize) ; i < datSize ; i++)
        if (stateMove[i] != b[i]) 
            isSame = 0;
    return isSame;
}
bool Player1::data::sameState(const data& b)
{
    bool isSame = 1;
    for (int i = 0 ; i < stateSize ; i++)
        if (stateMove[i] != b.stateMove[i]) 
            isSame = 0; 
    return isSame;
}
bool Player1::data::sameMove(const data& b)
{
    bool isSame = 1;
    for (int i = (datSize-moveSize) ; i < datSize ; i++)
        if (stateMove[i] != b.stateMove[i]) 
            isSame = 0;
    return isSame;
}
char* Player1::data::dat(char* string) 
{
    stateMove = new char[datSize];
    for (int i = 0 ; i < datSize ; i++)
        stateMove[i] = string[i];

    return stateMove;
}
Player1::data::data(const data &obj) // copy constructor
{
    stateMove = new char[datSize+1]; // safety
    stateMove[datSize] = 0;
    for (int i = 0 ; i < datSize ; i++)
        stateMove[i] = obj.stateMove[i];
}

Move Player1::data::move()
{
    Move m;
    m.player = PLAYER1; // gets fixed by auto replace
    m.src_x = stateMove[stateSize+1] - '0';
    m.src_y = stateMove[stateSize+2] - '0';
    m.dst_x = stateMove[stateSize+3] - '0';
    m.dst_y = stateMove[stateSize+4] - '0';

    return m;
}
board Player1::data::state()
{
    board bord;
    for (int i = 0 ; i < XYDIM ; i++)
        for (int j = 0 ; j < XYDIM ; j++)
        {
            bord.layout[i][j] = stateMove[i*XYDIM+j] - '0';
        }
    return bord;
}

Move Player1::data::move(Move mov)
{
    stateMove[stateSize+0] = mov.player + '0';
    stateMove[stateSize+1] = mov.src_x + '0';
    stateMove[stateSize+2] = mov.src_y + '0';
    stateMove[stateSize+3] = mov.dst_x + '0';
    stateMove[stateSize+4] = mov.dst_y + '0';

    return mov;
}

board Player1::data::state(board bord)
{
    for (int i = 0 ; i < XYDIM ; i++)
        for (int j = 0 ; j < XYDIM ; j++)
        {
            stateMove[i*XYDIM+j] = bord.layout[i][j] + '0';
        }

    return bord;
}
void Player1::data::player(unsigned short p)
{
    stateMove[stateSize+0] = p + '0';
}

bool Player1::data::safe(const data& b)
{
    for (int i = 0 ; i < stateSize ; i++)
        if (b.stateMove[i] > XYDIM)
            return 0;
    if (b.stateMove[stateSize] > 2) // only ever two players
        return 0;
    for (int i = stateSize+1 ; i < datSize ; i++)
        if (b.stateMove[i] > XYDIM-1)
            return 0;

    return 1; // safe
}
bool Player1::data::safe(char* b)
{
    for (int i = 0 ; i < stateSize ; i++)
        if (b[i] > XYDIM)
            return 0;
    if (b[stateSize] > 2) // only ever two players
        return 0;
    for (int i = stateSize+1 ; i < datSize ; i++)
        if (b[i] > XYDIM-1)
            return 0;

    return 1; // safe
}


// validmove: 'helper' function for helping a player determine whether a move is valid.
// Inputs: a move and a game board.
// Output: true if move is valid, false otherwise.
bool validmove(Move move, board game_board)
{
	short x, y;
	bool allclear;

	// First, verify that a player isn't trying to move another's stone.
	if (move.player != game_board.layout[move.src_y][move.src_x])
		return false;

	// Second, verify that a player actually tries to move somewhere...
	if (move.dst_y == move.src_y && move.dst_x == move.src_x)  // Wow - really?
		return false;

	// Check for invalid 'North' move.
	if (move.dst_y < move.src_y && move.dst_x == move.src_x) {

		y = move.src_y - 1;
		allclear = true;

		while (allclear && y >= 0)
			if (game_board.layout[y][move.dst_x] != EMPTY)
				allclear = false;
			else
				y--;

		y++;	// Went past the valid move cell, so back it up.

		if (move.dst_y != y)
			return false;
	}

	// Check for invalid 'South' move.
	if (move.dst_y > move.src_y && move.dst_x == move.src_x) {

		y = move.src_y + 1;
		allclear = true;

		while (allclear && y < XYDIM)
			if (game_board.layout[y][move.dst_x] != EMPTY)
				allclear = false;
			else
				y++;

		y--;	// Went past the valid move cell, so back it up.

		if (move.dst_y != y)
			return false;
	}

	// Check for invalid 'East' move.
	if (move.dst_y == move.src_y && move.dst_x > move.src_x) {

		x = move.src_x + 1;
		allclear = true;

		while (allclear && x < XYDIM)
			if (game_board.layout[move.dst_y][x] != EMPTY)
				allclear = false;
			else
				x++;

		x--;	// Went past the valid move cell, so back it up.

		if (move.dst_x != x)
			return false;
	}

	// Check for invalid 'West' move.
	if (move.dst_y == move.src_y && move.dst_x < move.src_x) {

		x = move.src_x - 1;
		allclear = true;

		while (allclear && x >= 0)
			if (game_board.layout[move.dst_y][x] != EMPTY)
				allclear = false;
			else
				x--;

		x++;	// Went past the valid move cell, so back it up.

		if (move.dst_x != x)
			return false;
	}

	// Check for invalid 'Northeast' move.
	if (move.dst_y < move.src_y && move.dst_x > move.src_x) {

		x = move.src_x + 1;
		y = move.src_y - 1;
		allclear = true;

		while (allclear && y >= 0 && x < XYDIM)
			if (game_board.layout[y][x] != EMPTY)
				allclear = false;
			else {
				x++;
				y--;
			}

			x--;	// Went past the valid move cell, so back it up.
			y++;

			if (move.dst_x != x || move.dst_y != y)
				return false;
	}

	// Check for invalid 'Northwest' move.
	if (move.dst_y < move.src_y && move.dst_x < move.src_x) {

		x = move.src_x - 1;
		y = move.src_y - 1;
		allclear = true;

		while (allclear && y >= 0 && x >= 0)	// Fix due to Kirt Guthrie.
			if (game_board.layout[y][x] != EMPTY)
				allclear = false;
			else {
				x--;
				y--;
			}

			x++;	// Went past the valid move cell, so back it up.
			y++;

			if (move.dst_x != x || move.dst_y != y)
				return false;
	}

	// Check for invalid 'Southeast' move.
	if (move.dst_y > move.src_y && move.dst_x > move.src_x) {

		x = move.src_x + 1;
		y = move.src_y + 1;
		allclear = true;

		while (allclear && y < XYDIM && x < XYDIM)
			if (game_board.layout[y][x] != EMPTY)
				allclear = false;
			else {
				x++;
				y++;
			}

			x--;	// Went past the valid move cell, so back it up.
			y--;

			if (move.dst_x != x || move.dst_y != y)
				return false;
	}

	// Check for invalid 'Southwest' move.
	if (move.dst_y > move.src_y && move.dst_x < move.src_x) {

		x = move.src_x - 1;
		y = move.src_y + 1;
		allclear = true;

		while (allclear && y < XYDIM && x >= 0)
			if (game_board.layout[y][x] != EMPTY)
				allclear = false;
			else {
				x--;
				y++;
			}

			x++;	// Went past the valid move cell, so back it up.
			y--;

			if (move.dst_x != x || move.dst_y != y)
				return false;
	}

	return true;   // Made it past all the checks - Valid move!
}

// isover: Checks whether the game is over.
// Inputs: a game board and a reference parameter for passing backa winner if any.
// Output: true if game is over, false otherwise.
bool isover(board game_board)
{
    int winner;
	unsigned short x, y;
	bool gameover = false;

#define gbl game_board.layout
/*
    for (int i = 0 ; i < XYDIM ; i++)
    {
        for (int j = 0 ; j < XYDIM ; j++)
            cout << ' ' << gbl[i][j];
        cout << endl;
    }
*/
/*

    cout << (game_board.layout[0][0] == game_board.layout[0][3] &&
		game_board.layout[0][0] == game_board.layout[3][0] &&
		game_board.layout[0][0] == game_board.layout[3][3] &&
		game_board.layout[0][0] != EMPTY) << ' ';

	cout <<(game_board.layout[0][0] != EMPTY && 
        game_board.layout[0][1] != EMPTY &&
		game_board.layout[1][0] != EMPTY && 
        game_board.layout[1][1] != EMPTY &&
		game_board.layout[0][0] != game_board.layout[0][1] &&
		game_board.layout[0][0] != game_board.layout[1][0] &&
		game_board.layout[0][0] != game_board.layout[1][1]);

	cout << (game_board.layout[0][3] != EMPTY && 
        game_board.layout[0][2] != EMPTY &&
		game_board.layout[1][3] != EMPTY && 
        game_board.layout[1][2] != EMPTY &&
		game_board.layout[0][3] != game_board.layout[0][2] &&
		game_board.layout[0][3] != game_board.layout[1][3] &&
		game_board.layout[0][3] != game_board.layout[1][2]);

	cout << (game_board.layout[3][0] != EMPTY && 
        game_board.layout[3][1] != EMPTY &&
		game_board.layout[2][0] != EMPTY && 
        game_board.layout[2][1] != EMPTY &&
		game_board.layout[3][0] != game_board.layout[3][1] &&
		game_board.layout[3][0] != game_board.layout[2][0] &&
		game_board.layout[3][0] != game_board.layout[2][1]);

	cout << (game_board.layout[3][3] != EMPTY && 
        game_board.layout[3][2] != EMPTY &&
		game_board.layout[2][3] != EMPTY && 
        game_board.layout[2][2] != EMPTY &&
		game_board.layout[3][3] != game_board.layout[3][2] &&
		game_board.layout[3][3] != game_board.layout[2][3] &&
		game_board.layout[3][3] != game_board.layout[2][2]);


	for (x = 0; x < XYDIM; x++)
		cout << (game_board.layout[0][x] != EMPTY && 
            game_board.layout[1][x] == game_board.layout[0][x] && 
            game_board.layout[2][x] == game_board.layout[0][x] && 
            game_board.layout[3][x] == game_board.layout[0][x]);
*/

	// Check for a 'four corners' victory.
	if (game_board.layout[0][0] == game_board.layout[0][3] &&
		game_board.layout[0][0] == game_board.layout[3][0] &&
		game_board.layout[0][0] == game_board.layout[3][3] &&
		game_board.layout[0][0] != EMPTY) {

		gameover = true;
		winner = game_board.layout[0][0];

		return gameover;
	}
	// Check for a 'backdoor' victory.


	if (game_board.layout[0][0] != EMPTY && 
        game_board.layout[0][1] != EMPTY &&
		game_board.layout[1][0] != EMPTY && 
        game_board.layout[1][1] != EMPTY &&
		game_board.layout[0][0] != game_board.layout[0][1] &&
		game_board.layout[0][0] != game_board.layout[1][0] &&
		game_board.layout[0][0] != game_board.layout[1][1]) {

		gameover = true;
		winner = game_board.layout[0][0];

		return gameover;
	}

	if (game_board.layout[0][3] != EMPTY && 
        game_board.layout[0][2] != EMPTY &&
		game_board.layout[1][3] != EMPTY && 
        game_board.layout[1][2] != EMPTY &&
		game_board.layout[0][3] != game_board.layout[0][2] &&
		game_board.layout[0][3] != game_board.layout[1][3] &&
		game_board.layout[0][3] != game_board.layout[1][2]) {

		gameover = true;
		winner = game_board.layout[0][3];

		return gameover;
	}
	if (game_board.layout[3][0] != EMPTY && 
        game_board.layout[3][1] != EMPTY &&
		game_board.layout[2][0] != EMPTY && 
        game_board.layout[2][1] != EMPTY &&
		game_board.layout[3][0] != game_board.layout[3][1] &&
		game_board.layout[3][0] != game_board.layout[2][0] &&
		game_board.layout[3][0] != game_board.layout[2][1]) {

		gameover = true;
		winner = game_board.layout[3][0];

		return gameover;
	}
	if (game_board.layout[3][3] != EMPTY && 
        game_board.layout[3][2] != EMPTY &&
		game_board.layout[2][3] != EMPTY && 
        game_board.layout[2][2] != EMPTY &&
		game_board.layout[3][3] != game_board.layout[3][2] &&
		game_board.layout[3][3] != game_board.layout[2][3] &&
		game_board.layout[3][3] != game_board.layout[2][2]) {

		gameover = true;
		winner = game_board.layout[3][3];

		return gameover;
	}


	// Check for 'column' victory.
	for (x = 0; x < XYDIM; x++)
		if (game_board.layout[0][x] != EMPTY && 
            game_board.layout[1][x] == game_board.layout[0][x] && 
            game_board.layout[2][x] == game_board.layout[0][x] && 
            game_board.layout[3][x] == game_board.layout[0][x]) {

			gameover = true;
			winner = game_board.layout[0][x];

			return gameover;
		}


/*
	for (y = 0; y < XYDIM; y++)
	cout << (game_board.layout[y][0] != EMPTY && 
            game_board.layout[y][1] == game_board.layout[y][0] && 
            game_board.layout[y][2] == game_board.layout[y][0] && 
            game_board.layout[y][3] == game_board.layout[y][0]);
    cout << ' ';

	for (y = 0; y < XYDIM - 1; y++)
	 for (x = 0; x < XYDIM - 1; x++)
         cout << (game_board.layout[y][x] != EMPTY && 
             game_board.layout[y][x] == game_board.layout[y+1][x] && 
             game_board.layout[y][x] == game_board.layout[y][x+1] && 
             game_board.layout[y][x] == game_board.layout[y+1][x+1]);
    cout << ' ';
*/

	// Check for 'row' victory.
	for (y = 0; y < XYDIM; y++)
		if (game_board.layout[y][0] != EMPTY && 
            game_board.layout[y][1] == game_board.layout[y][0] && 
            game_board.layout[y][2] == game_board.layout[y][0] && 
            game_board.layout[y][3] == game_board.layout[y][0]) {

			gameover = true;
			winner = game_board.layout[y][0];

			return gameover;
		}



	// Check for 'square cluster' victory.
	for (y = 0; y < XYDIM - 1; y++)
	 for (x = 0; x < XYDIM - 1; x++)
         if (game_board.layout[y][x] != EMPTY && 
             game_board.layout[y][x] == game_board.layout[y+1][x] && 
             game_board.layout[y][x] == game_board.layout[y][x+1] && 
             game_board.layout[y][x] == game_board.layout[y+1][x+1]) {

				gameover = true;
				winner = game_board.layout[y][x];

				return gameover;
			}


	return gameover;
}

Move randMove(int p)
{
    Move move;
    move.player = p;
    move.src_x = rand() % XYDIM;
    move.src_y = rand() % XYDIM;
    move.dst_x = rand() % XYDIM;
    move.dst_y = rand() % XYDIM;

    return move;
}

list<Move> safeSpace(board game_board, int p, int depth)
{
    list<Move> moves;

    // layer 1: non-agressive
    moves = safeSpaceMe(game_board,p);

    cout << "player1 L1 moves: " << moves.size() << endl; // I wonder...

    // layer 2: defensive
    p=(p==1)?2:1;
    list<Move> moved = moves; // backup
    for (list<Move>::iterator iter = moves.begin();
         iter != moves.end();
         iter++)
    {
        board testBoard = makeMove(game_board, *iter);
        if (defense(testBoard, p)) //needs to be based on p
            iter = moves.erase(iter);
    }
    cout << "player1 L2 moves: " << moves.size() << endl; // I wonder...
    
    if (moves.size() == 0) //well.. better have layer 1 than nothing
        moves = moved;

    // layer n
    if (depth != 0)
    {
        for (list<Move>::iterator iter = moves.begin();
             iter != moves.end();
             iter++)
        {
            board testBoard = makeMove(game_board, *iter);
            if (safeSpace(testBoard, p, depth-1).empty())
                iter = moves.erase(iter);
        }
            
    }
    cout << endl;

    return moves;
}

list<Move> safeSpaceMe(board game_board, int p) //expander
{
    list<Move> moves;
    Move testMove;
    int winner = 0;

    // get valid move
    for (int i = 0 ; i < XYDIM ; i++)
     for (int j = 0 ; j < XYDIM ; j++)
      for (int k = 0 ; k < XYDIM ; k++)
       for (int l = 0 ; l < XYDIM ; l++)
       {
         testMove.player = p;
         testMove.src_x = i;
         testMove.src_y = j;
         testMove.dst_x = k;
         testMove.dst_y = l;
                    
         board testBoard = makeMove(game_board, testMove);
         if (validmove(testMove, game_board)) //play valid move
           if (!(isover(testBoard))) //avoid ending game
            moves.push_front(testMove); 
       }
    return moves;
}

bool defense(board game_board, int p) // pruner
{
    Move testMove;

    // get valid move
    for (int i = 0 ; i < XYDIM ; i++)
     for (int j = 0 ; j < XYDIM ; j++)
      for (int k = 0 ; k < XYDIM ; k++)
       for (int l = 0 ; l < XYDIM ; l++)
       {
         testMove.player = p;
         testMove.src_x = i;
         testMove.src_y = j;
         testMove.dst_x = k;
         testMove.dst_y = l;
                    
         board testBoard = makeMove(game_board, testMove);
         if (validmove(testMove, game_board)) //play valid move
           if (!(isover(testBoard))) //avoid ending game
            return 1; // defence failed
       }
    return 0; // safe
}

board makeMove(board game_board, Move move)
{
    game_board.layout[move.src_y][move.src_x] = 0;
    game_board.layout[move.dst_y][move.dst_x] = move.player;

    return game_board;
}


#endif
