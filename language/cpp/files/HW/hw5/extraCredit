/*********************************************************************
  Author:        Jordan Winkler, IUSB, CS
  Class:         C243 Data Structures
  File name:     extraCredit
  Last updated:  October 3, 2017
*********************************************************************/


Here are three hash functions I tested. The first is a prime based 
polynomial. The second is linearly scaled. The last, and the one I 
had to go with, was recommended in the notes. I created s-expressions 
so I could easily test how each hash function did. The first measure 
was variance from 1. I wanted to see how far from acceptable use each 
function varied. The three other metrics are mostly variations of this 
one. It seems that hash function 3 did best.

    int hashVal = 0;
    for (int i = 0; i < k.length() ; ++i)
        hashVal += (int(k[i]) * int(pow(151, i))) % capacity;
    if (hashVal < 0)
        hashVal *= -1;
    return hashVal % capacity;

(define hash1 
(list 0 0 1 1 0 0 1 0 1 1 3 0 2 0 1 1 1 1 0 0 1 3 0 0 0 3 1 0 1 0 0 0 1 0 3 1 2 2 1 0 1 0 1 2 2 4 0 0 1 1 0 1 1 0 3 1 2 0 1 2 1 1 1 3 0 1 0 0 1 0 0 3 2 0 1 1 3 0 0 3 2 2 0 0 4 1 4 1 3 4 1 4 0 0 1 2 1 3 0 1 2 1 2 1 3 3 1 1 1 0 0 3 0 1 1 0 1 0 1 0 3 1 1 0 0 1 0 2 1 2 1 1 3 0 0 2 0 1 1 0 1 1 1 0 0 1 3 2 1 2 0 0 1 0 0 2 1 0 5 0 1 1 0 1 1 0 0 0 1 2 3 2 0 1 0 3 1 1 0 1 1 0 2 2 1 2 1 0 2 0 2 0 1 0 2 0 0 0 0 0 1 2 0 0 1 0 1 1 0 0 2 1 0 0 1 3 1 2 0 2 0 1 0 1 0 0 1 1 1 0 1 1 2 1 1 2 1 1 2 0 1 1 1 1 2 1 0 3 1 0 1 1 1 0 0 0 0 1 2 0 1 0 1 1 0 2 0 2 1 0 0 0 0 1 1 1 1 4 1 0 1 1 0 0 0 2 2 1 0 2 2 1 1 3 2 2 1 1 1 2 0 3 1 1 0 1 1 1 0 0 1 0 0 0 2 1 0 0 1 0 0 1 1 0 1 ))
> (average hash1) 319/325
> (variance 1 hash1) 18/25
> (variance (average hash1) hash1) 15312/21125
> (averageUse hash1) 41/65
> (collisionRate hash1) 24/65

    int hashVal = 0;
    for (int i = 0; i < k.length() ; ++i)
        hashVal += (5 * i + 3) * int(k[i]);
    return hashVal % capacity;

(define hash2
(list 0 0 1 0 0 0 0 1 0 0 1 1 1 1 0 1 1 2 0 0 0 0 2 0 1 3 1 3 3 0 0 1 1 0 1 0 0 1 1 0 1 1 0 1 1 1 0 2 0 0 0 2 1 0 1 0 0 0 1 0 1 2 1 2 0 1 0 0 0 0 0 0 2 1 1 0 3 0 2 2 0 1 1 0 0 1 0 0 1 0 1 1 2 1 0 1 2 0 1 0 2 1 0 1 1 1 0 0 1 1 0 0 0 2 1 3 1 1 0 1 1 1 4 0 0 1 3 1 0 1 1 1 1 2 0 0 1 0 4 1 1 1 1 1 2 2 2 2 1 0 0 3 1 2 1 1 2 0 1 1 2 1 4 0 0 4 0 1 0 1 2 0 1 1 2 1 0 1 0 0 4 0 1 0 0 1 0 1 1 0 3 2 1 1 1 1 5 2 3 1 2 1 0 1 0 0 0 2 2 2 1 1 1 1 1 4 1 1 2 1 2 3 1 0 1 0 0 0 4 0 2 0 0 1 0 0 2 1 1 0 1 3 0 3 1 4 0 1 4 2 0 1 0 1 0 1 1 3 2 1 3 1 0 2 0 0 0 0 1 1 2 1 3 1 2 0 1 1 0 0 2 0 0 0 1 0 1 3 4 1 2 1 0 0 1 0 4 1 0 2 2 0 0 1 1 0 1 1 2 0 0 1 1 1 0 2 1 0 0 1 2 2 2 0 0 ))
> (variance 1 hash2) 238/325
> (variance (average hash2) hash2) 77836/105625
> (averageUse hash2)  203/325
> (collisionRate hash2)  122/325


    int hashVal = 0;
    //k.length() is O(1) in language standard as of c++11
    for (int i = 0; i < k.length() ; ++i) 
    {
        int temp = (hashVal << 5) ^ int(k[i]);
        hashVal = temp ^ hashVal;
    }
    if (hashVal < 0) // c++ mod can be negative, but c++ index cannot
        hashVal *= -1;
    return hashVal % capacity;

(define hash3 
(list 1 1 1 2 1 0 3 0 1 0 2 1 1 1 1 2 0 0 1 0 1 0 1 1 1 0 2 1 1 2 0 1 2 3 1 0 0 1 0 1 2 0 0 0 0 0 0 1 1 1 2 1 0 2 3 1 2 1 0 0 1 1 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 3 1 0 1 0 0 4 0 2 0 0 1 2 1 2 1 3 2 1 1 1 1 2 1 1 0 1 1 2 1 4 0 0 0 0 1 1 2 4 1 2 1 0 2 1 1 0 2 1 0 4 0 1 0 3 2 2 0 1 1 3 0 2 1 0 3 1 0 0 0 0 0 2 0 0 1 1 2 1 0 0 0 0 2 1 0 2 2 0 0 0 1 0 0 1 0 0 2 1 0 0 1 3 2 2 2 1 0 0 1 1 1 1 1 1 1 1 3 3 2 1 0 3 1 1 2 0 1 1 1 3 0 1 0 0 0 0 1 1 0 5 1 1 1 2 1 0 0 0 0 1 3 0 4 1 0 1 1 0 1 0 1 1 0 2 1 2 1 1 2 1 0 0 0 3 1 0 0 2 2 0 1 1 2 0 2 1 0 2 1 1 1 2 0 1 0 3 1 3 2 0 0 1 0 0 0 0 1 1 3 1 1 1 0 2 0 0 1 0 0 0 0 0 1 0 0 2 3 1 2 1 3 4 1 4 0 1 0 1 1 0 0 1 0 1 1 2 1 ))
> (variance 1 hash3) 18/25
> (variance (average hash3) hash3) 15312/21125
> (averageUse hash3) 41/65
> (collisionRate hash3) 24/65