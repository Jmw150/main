;;;; ec.import.scm - GENERATED BY CHICKEN 4.13.0 -*- Scheme -*-

(eval '(import scheme (except chicken :)))
(##sys#register-compiled-module
  'ec
  (list '(ec-:vector-filter . ec#ec-:vector-filter)
        '(:-dispatch . ec#:-dispatch))
  '((dispatch-union . ec#dispatch-union)
    (make-initial-:-dispatch . ec#make-initial-:-dispatch)
    (:-dispatch-ref . ec#:-dispatch-ref)
    (:-dispatch-set! . ec#:-dispatch-set!))
  (list (cons 'every?-ec
              (syntax-rules
                (nested)
                ((every?-ec (nested q1 ...) q etc1 etc ...)
                 (every?-ec (nested q1 ... q) etc1 etc ...))
                ((every?-ec q1 q2 etc1 etc ...)
                 (every?-ec (nested q1 q2) etc1 etc ...))
                ((every?-ec expression) (every?-ec (nested) expression))
                ((every?-ec qualifier expression)
                 (first-ec #t qualifier (if (not expression)) #f))))
        (cons 'any?-ec
              (syntax-rules
                (nested)
                ((any?-ec (nested q1 ...) q etc1 etc ...)
                 (any?-ec (nested q1 ... q) etc1 etc ...))
                ((any?-ec q1 q2 etc1 etc ...)
                 (any?-ec (nested q1 q2) etc1 etc ...))
                ((any?-ec expression) (any?-ec (nested) expression))
                ((any?-ec qualifier expression)
                 (first-ec #f qualifier (if expression) #t))))
        (cons 'ec-guarded-do-ec
              (syntax-rules
                (nested if not and or begin)
                ((ec-guarded-do-ec stop (nested (nested q1 ...) q2 ...) cmd)
                 (ec-guarded-do-ec stop (nested q1 ... q2 ...) cmd))
                ((ec-guarded-do-ec stop (nested (if test) q ...) cmd)
                 (if test (ec-guarded-do-ec stop (nested q ...) cmd)))
                ((ec-guarded-do-ec stop (nested (not test) q ...) cmd)
                 (if (not test) (ec-guarded-do-ec stop (nested q ...) cmd)))
                ((ec-guarded-do-ec stop (nested (and test ...) q ...) cmd)
                 (if (and test ...)
                   (ec-guarded-do-ec stop (nested q ...) cmd)))
                ((ec-guarded-do-ec stop (nested (or test ...) q ...) cmd)
                 (if (or test ...) (ec-guarded-do-ec stop (nested q ...) cmd)))
                ((ec-guarded-do-ec stop (nested (begin etc ...) q ...) cmd)
                 (begin etc ... (ec-guarded-do-ec stop (nested q ...) cmd)))
                ((ec-guarded-do-ec stop (nested gen q ...) cmd)
                 (do-ec (:until gen stop)
                        (ec-guarded-do-ec stop (nested q ...) cmd)))
                ((ec-guarded-do-ec stop (nested) cmd) (do-ec cmd))))
        (cons 'first-ec
              (syntax-rules
                (nested)
                ((first-ec default (nested q1 ...) q etc1 etc ...)
                 (first-ec default (nested q1 ... q) etc1 etc ...))
                ((first-ec default q1 q2 etc1 etc ...)
                 (first-ec default (nested q1 q2) etc1 etc ...))
                ((first-ec default expression)
                 (first-ec default (nested) expression))
                ((first-ec default qualifier expression)
                 (let ((result default) (stop #f))
                   (ec-guarded-do-ec
                     stop
                     (nested qualifier)
                     (begin (set! result expression) (set! stop #t)))
                   result))))
        (cons 'last-ec
              (syntax-rules
                (nested)
                ((last-ec default (nested q1 ...) q etc1 etc ...)
                 (last-ec default (nested q1 ... q) etc1 etc ...))
                ((last-ec default q1 q2 etc1 etc ...)
                 (last-ec default (nested q1 q2) etc1 etc ...))
                ((last-ec default expression)
                 (last-ec default (nested) expression))
                ((last-ec default qualifier expression)
                 (let ((result default))
                   (do-ec qualifier (set! result expression))
                   result))))
        (cons 'max-ec
              (syntax-rules
                ()
                ((max-ec etc1 etc ...) (fold3-ec (max) etc1 etc ... max max))))
        (cons 'min-ec
              (syntax-rules
                ()
                ((min-ec etc1 etc ...) (fold3-ec (min) etc1 etc ... min min))))
        (cons 'product-ec
              (syntax-rules
                ()
                ((product-ec etc1 etc ...) (fold-ec (*) etc1 etc ... *))))
        (cons 'sum-ec
              (syntax-rules
                ()
                ((sum-ec etc1 etc ...) (fold-ec (+) etc1 etc ... +))))
        (cons 'vector-of-length-ec
              (syntax-rules
                (nested)
                ((vector-of-length-ec k (nested q1 ...) q etc1 etc ...)
                 (vector-of-length-ec k (nested q1 ... q) etc1 etc ...))
                ((vector-of-length-ec k q1 q2 etc1 etc ...)
                 (vector-of-length-ec k (nested q1 q2) etc1 etc ...))
                ((vector-of-length-ec k expression)
                 (vector-of-length-ec k (nested) expression))
                ((vector-of-length-ec k qualifier expression)
                 (let ((len k))
                   (let ((vec (make-vector len)) (i 0))
                     (do-ec qualifier
                            (if (< i len)
                              (begin
                                (vector-set! vec i expression)
                                (set! i (+ i 1)))
                              (error "vector is too short for the comprehension")))
                     (if (= i len)
                       vec
                       (error "vector is too long for the comprehension")))))))
        (cons 'vector-ec
              (syntax-rules
                ()
                ((vector-ec etc1 etc ...)
                 (list->vector (list-ec etc1 etc ...)))))
        (cons 'string-append-ec
              (syntax-rules
                ()
                ((string-append-ec etc1 etc ...)
                 (apply string-append (list-ec etc1 etc ...)))))
        (cons 'string-ec
              (syntax-rules
                ()
                ((string-ec etc1 etc ...)
                 (list->string (list-ec etc1 etc ...)))))
        (cons 'append-ec
              (syntax-rules
                ()
                ((append-ec etc1 etc ...)
                 (apply append (list-ec etc1 etc ...)))))
        (cons 'list-ec
              (syntax-rules
                ()
                ((list-ec etc1 etc ...)
                 (reverse (fold-ec '() etc1 etc ... cons)))))
        (cons 'fold-ec
              (syntax-rules
                (nested)
                ((fold-ec x0 (nested q1 ...) q etc1 etc2 etc ...)
                 (fold-ec x0 (nested q1 ... q) etc1 etc2 etc ...))
                ((fold-ec x0 q1 q2 etc1 etc2 etc ...)
                 (fold-ec x0 (nested q1 q2) etc1 etc2 etc ...))
                ((fold-ec x0 expression f2)
                 (fold-ec x0 (nested) expression f2))
                ((fold-ec x0 qualifier expression f2)
                 (let ((result x0))
                   (do-ec qualifier (set! result (f2 expression result)))
                   result))))
        (cons 'fold3-ec
              (syntax-rules
                (nested)
                ((fold3-ec x0 (nested q1 ...) q etc1 etc2 etc3 etc ...)
                 (fold3-ec x0 (nested q1 ... q) etc1 etc2 etc3 etc ...))
                ((fold3-ec x0 q1 q2 etc1 etc2 etc3 etc ...)
                 (fold3-ec x0 (nested q1 q2) etc1 etc2 etc3 etc ...))
                ((fold3-ec x0 expression f1 f2)
                 (fold3-ec x0 (nested) expression f1 f2))
                ((fold3-ec x0 qualifier expression f1 f2)
                 (let ((result #f) (empty #t))
                   (do-ec qualifier
                          (let ((value expression))
                            (if empty
                              (begin (set! result (f1 value)) (set! empty #f))
                              (set! result (f2 value result)))))
                   (if empty x0 result)))))
        (cons ':
              (syntax-rules
                (index)
                ((: cc var (index i) arg1 arg ...)
                 (:dispatched cc var (index i) :-dispatch arg1 arg ...))
                ((: cc var arg1 arg ...)
                 (:dispatched cc var :-dispatch arg1 arg ...))))
        (cons ':generator-proc
              (syntax-rules
                (:do let)
                ((:generator-proc (g arg ...))
                 (g (:generator-proc var) var arg ...))
                ((:generator-proc
                   var
                   (:do (let obs oc ...)
                        ((lv li) ...)
                        ne1?
                        (let ((i v) ...) ic ...)
                        ne2?
                        (ls ...)))
                 (ec-simplify
                   (let obs oc
                     ...
                     (let ((lv li) ... (ne2 #t))
                       (ec-simplify
                         (let ((i #f) ...)
                           (lambda (empty)
                             (if (and ne1? ne2)
                               (ec-simplify
                                 (begin
                                   (set! i v)
                                   ...
                                   ic
                                   ...
                                   (let ((value var))
                                     (ec-simplify
                                       (if ne2?
                                         (ec-simplify (begin (set! lv ls) ...))
                                         (set! ne2 #f)))
                                     value)))
                               empty))))))))
                ((:generator-proc var) (error "illegal macro call"))))
        (cons ':dispatched
              (syntax-rules
                (index)
                ((:dispatched cc var (index i) dispatch arg1 arg ...)
                 (:parallel
                   cc
                   (:integers i)
                   (:dispatched var dispatch arg1 arg ...)))
                ((:dispatched cc var dispatch arg1 arg ...)
                 (:do cc
                      (let ((d dispatch)
                            (args (list arg1 arg ...))
                            (g #f)
                            (empty (list #f)))
                        (set! g (d args))
                        (if (not (procedure? g))
                          (error "unrecognized arguments in dispatching"
                                 args
                                 (d '()))))
                      ((var (g empty)))
                      (not (eq? var empty))
                      (let ())
                      #t
                      ((g empty))))))
        (cons ':port
              (syntax-rules
                (index)
                ((:port cc var (index i) arg1 arg ...)
                 (:parallel cc (:port var arg1 arg ...) (:integers i)))
                ((:port cc var arg) (:port cc var arg read))
                ((:port cc var arg1 arg2)
                 (:do cc
                      (let ((port arg1) (read-proc arg2)))
                      ((var (read-proc port)))
                      (not (eof-object? var))
                      (let ())
                      #t
                      ((read-proc port))))))
        (cons ':char-range
              (syntax-rules
                (index)
                ((:char-range cc var (index i) arg1 arg2)
                 (:parallel cc (:char-range var arg1 arg2) (:integers i)))
                ((:char-range cc var arg1 arg2)
                 (:do cc
                      (let ((imax (char->integer arg2))))
                      ((i (char->integer arg1)))
                      (<= i imax)
                      (let ((var (integer->char i))))
                      #t
                      ((+ i 1))))))
        (cons ':real-range
              (syntax-rules
                (index)
                ((:real-range cc var arg1)
                 (:real-range cc var (index i) 0 arg1 1))
                ((:real-range cc var (index i) arg1)
                 (:real-range cc var (index i) 0 arg1 1))
                ((:real-range cc var arg1 arg2)
                 (:real-range cc var (index i) arg1 arg2 1))
                ((:real-range cc var (index i) arg1 arg2)
                 (:real-range cc var (index i) arg1 arg2 1))
                ((:real-range cc var arg1 arg2 arg3)
                 (:real-range cc var (index i) arg1 arg2 arg3))
                ((:real-range cc var (index i) arg1 arg2 arg3)
                 (:do cc
                      (let ((a arg1) (b arg2) (s arg3) (istop 0))
                        (if (not (and (real? a) (real? b) (real? s)))
                          (error "arguments of :real-range are not real"
                                 a
                                 b
                                 s))
                        (if (and (exact? a)
                                 (or (not (exact? b)) (not (exact? s))))
                          (set! a (exact->inexact a)))
                        (set! istop (/ (- b a) s)))
                      ((i 0))
                      (< i istop)
                      (let ((var (+ a (* s i)))))
                      #t
                      ((+ i 1))))))
        (cons ':range
              (syntax-rules
                (index)
                ((:range cc var (index i) arg1 arg ...)
                 (:parallel cc (:range var arg1 arg ...) (:integers i)))
                ((:range cc var arg1) (:range cc var 0 arg1 1))
                ((:range cc var arg1 arg2) (:range cc var arg1 arg2 1))
                ((:range cc var 0 arg2 1)
                 (:do cc
                      (let ((b arg2))
                        (if (not (and (integer? b) (exact? b)))
                          (error "arguments of :range are not exact integer "
                                 "(use :real-range?)"
                                 0
                                 b
                                 1)))
                      ((var 0))
                      (< var b)
                      (let ())
                      #t
                      ((+ var 1))))
                ((:range cc var 0 arg2 -1)
                 (:do cc
                      (let ((b arg2))
                        (if (not (and (integer? b) (exact? b)))
                          (error "arguments of :range are not exact integer "
                                 "(use :real-range?)"
                                 0
                                 b
                                 1)))
                      ((var 0))
                      (> var b)
                      (let ())
                      #t
                      ((- var 1))))
                ((:range cc var arg1 arg2 1)
                 (:do cc
                      (let ((a arg1) (b arg2))
                        (if (not (and (integer? a)
                                      (exact? a)
                                      (integer? b)
                                      (exact? b)))
                          (error "arguments of :range are not exact integer "
                                 "(use :real-range?)"
                                 a
                                 b
                                 1)))
                      ((var a))
                      (< var b)
                      (let ())
                      #t
                      ((+ var 1))))
                ((:range cc var arg1 arg2 -1)
                 (:do cc
                      (let ((a arg1) (b arg2) (s -1) (stop 0))
                        (if (not (and (integer? a)
                                      (exact? a)
                                      (integer? b)
                                      (exact? b)))
                          (error "arguments of :range are not exact integer "
                                 "(use :real-range?)"
                                 a
                                 b
                                 -1)))
                      ((var a))
                      (> var b)
                      (let ())
                      #t
                      ((- var 1))))
                ((:range cc var arg1 arg2 arg3)
                 (:do cc
                      (let ((a arg1) (b arg2) (s arg3) (stop 0))
                        (if (not (and (integer? a)
                                      (exact? a)
                                      (integer? b)
                                      (exact? b)
                                      (integer? s)
                                      (exact? s)))
                          (error "arguments of :range are not exact integer "
                                 "(use :real-range?)"
                                 a
                                 b
                                 s))
                        (if (zero? s)
                          (error "step size must not be zero in :range"))
                        (set! stop
                          (+ a (* (max 0 (ceiling (/ (- b a) s))) s))))
                      ((var a))
                      (not (= var stop))
                      (let ())
                      #t
                      ((+ var s))))))
        (cons ':integers
              (syntax-rules
                (index)
                ((:integers cc var (index i))
                 (:do cc ((var 0) (i 0)) #t ((+ var 1) (+ i 1))))
                ((:integers cc var) (:do cc ((var 0)) #t ((+ var 1))))))
        (cons ':vector
              (syntax-rules
                (index)
                ((:vector cc var arg) (:vector cc var (index i) arg))
                ((:vector cc var (index i) arg)
                 (:do cc
                      (let ((vec arg) (len 0)) (set! len (vector-length vec)))
                      ((i 0))
                      (< i len)
                      (let ((var (vector-ref vec i))))
                      #t
                      ((+ i 1))))
                ((:vector cc var (index i) arg1 arg2 arg ...)
                 (:parallel
                   cc
                   (:vector cc var arg1 arg2 arg ...)
                   (:integers i)))
                ((:vector cc var arg1 arg2 arg ...)
                 (:do cc
                      (let ((vec #f)
                            (len 0)
                            (vecs (ec-:vector-filter (list arg1 arg2 arg ...)))))
                      ((k 0))
                      (if (< k len)
                        #t
                        (if (null? vecs)
                          #f
                          (begin
                            (set! vec (car vecs))
                            (set! vecs (cdr vecs))
                            (set! len (vector-length vec))
                            (set! k 0)
                            #t)))
                      (let ((var (vector-ref vec k))))
                      #t
                      ((+ k 1))))))
        (cons ':string
              (syntax-rules
                (index)
                ((:string cc var (index i) arg)
                 (:do cc
                      (let ((str arg) (len 0)) (set! len (string-length str)))
                      ((i 0))
                      (< i len)
                      (let ((var (string-ref str i))))
                      #t
                      ((+ i 1))))
                ((:string cc var (index i) arg1 arg2 arg ...)
                 (:string cc var (index i) (string-append arg1 arg2 arg ...)))
                ((:string cc var arg1 arg ...)
                 (:string cc var (index i) arg1 arg ...))))
        (cons ':list
              (syntax-rules
                (index)
                ((:list cc var (index i) arg ...)
                 (:parallel cc (:list var arg ...) (:integers i)))
                ((:list cc var arg1 arg2 arg ...)
                 (:list cc var (append arg1 arg2 arg ...)))
                ((:list cc var arg)
                 (:do cc
                      (let ())
                      ((t arg))
                      (not (null? t))
                      (let ((var (car t))))
                      #t
                      ((cdr t))))))
        (cons ':until-1
              (syntax-rules
                (:do)
                ((:until-1 cc test (:do olet lbs ne1? ilet ne2? lss))
                 (:do cc olet lbs ne1? ilet (and ne2? (not test)) lss))))
        (cons ':until
              (syntax-rules
                ()
                ((:until cc (g arg1 arg ...) test)
                 (g (:until-1 cc test) arg1 arg ...))))
        (cons ':while-2
              (syntax-rules
                (:do let)
                ((:while-2
                   cc
                   test
                   (ib-let ...)
                   (ib-save ...)
                   (ib-restore ...)
                   (:do olet
                        lbs
                        ne1?
                        (let ((ib-var ib-rhs) ib ...) ic ...)
                        ne2?
                        lss))
                 (:while-2
                   cc
                   test
                   (ib-let ... (ib-tmp #f))
                   (ib-save ... (ib-var ib-rhs))
                   (ib-restore ... (ib-var ib-tmp))
                   (:do olet
                        lbs
                        ne1?
                        (let (ib ...) ic ... (set! ib-tmp ib-var))
                        ne2?
                        lss)))
                ((:while-2
                   cc
                   test
                   (ib-let ...)
                   (ib-save ...)
                   (ib-restore ...)
                   (:do (let (ob ...) oc ...)
                        lbs
                        ne1?
                        (let () ic ...)
                        ne2?
                        lss))
                 (:do cc
                      (let (ob ... ib-let ...) oc ...)
                      lbs
                      (let ((ne1?-value ne1?))
                        (and ne1?-value (let (ib-save ...) ic ... test)))
                      (let (ib-restore ...))
                      ne2?
                      lss))))
        (cons ':while-1
              (syntax-rules
                (:do let)
                ((:while-1 cc test (:do olet lbs ne1? ilet ne2? lss))
                 (:while-2
                   cc
                   test
                   ()
                   ()
                   ()
                   (:do olet lbs ne1? ilet ne2? lss)))))
        (cons ':while
              (syntax-rules
                ()
                ((:while cc (g arg1 arg ...) test)
                 (g (:while-1 cc test) arg1 arg ...))))
        (cons ':parallel-1
              (syntax-rules
                (:do let)
                ((:parallel-1 cc ((g arg1 arg ...) gen ...) result)
                 (g (:parallel-1 cc (gen ...) result) arg1 arg ...))
                ((:parallel-1
                   cc
                   gens
                   (:do (let (ob1 ...) oc1 ...)
                        (lb1 ...)
                        ne1?1
                        (let (ib1 ...) ic1 ...)
                        ne2?1
                        (ls1 ...))
                   (:do (let (ob2 ...) oc2 ...)
                        (lb2 ...)
                        ne1?2
                        (let (ib2 ...) ic2 ...)
                        ne2?2
                        (ls2 ...)))
                 (:parallel-1
                   cc
                   gens
                   (:do (let (ob1 ... ob2 ...) oc1 ... oc2 ...)
                        (lb1 ... lb2 ...)
                        (and ne1?1 ne1?2)
                        (let (ib1 ... ib2 ...) ic1 ... ic2 ...)
                        (and ne2?1 ne2?2)
                        (ls1 ... ls2 ...))))
                ((:parallel-1 (cc ...) () result) (cc ... result))))
        (cons ':parallel
              (syntax-rules
                (:do)
                ((:parallel cc) cc)
                ((:parallel cc (g arg1 arg ...) gen ...)
                 (g (:parallel-1 cc (gen ...)) arg1 arg ...))))
        (cons ':let
              (syntax-rules
                (index)
                ((:let cc var (index i) expression)
                 (:do cc (let ((var expression) (i 0))) () #t (let ()) #f ()))
                ((:let cc var expression)
                 (:do cc (let ((var expression))) () #t (let ()) #f ()))))
        (cons ':do
              (syntax-rules
                ()
                ((:do (cc ...) olet lbs ne1? ilet ne2? lss)
                 (cc ... (:do olet lbs ne1? ilet ne2? lss)))
                ((:do cc lbs ne1? lss)
                 (:do cc (let ()) lbs ne1? (let ()) #t lss))))
        (cons 'do-ec:do
              (syntax-rules
                (:do let)
                ((do-ec:do
                   cmd
                   (:do (let obs oc ...)
                        lbs
                        ne1?
                        (let ibs ic ...)
                        ne2?
                        (ls ...)))
                 (ec-simplify
                   (let obs oc
                     ...
                     (let loop lbs
                       (ec-simplify
                         (if ne1?
                           (ec-simplify
                             (let ibs ic
                               ...
                               cmd
                               (ec-simplify (if ne2? (loop ls ...)))))))))))))
        (cons 'do-ec
              (syntax-rules
                (nested if not and or begin :do let)
                ((do-ec (nested q ...) etc ...) (do-ec q ... etc ...))
                ((do-ec q1 q2 etc1 etc ...) (do-ec q1 (do-ec q2 etc1 etc ...)))
                ((do-ec cmd) (begin cmd (if #f #f)))
                ((do-ec (if test) cmd) (if test (do-ec cmd)))
                ((do-ec (not test) cmd) (if (not test) (do-ec cmd)))
                ((do-ec (and test ...) cmd) (if (and test ...) (do-ec cmd)))
                ((do-ec (or test ...) cmd) (if (or test ...) (do-ec cmd)))
                ((do-ec (begin etc ...) cmd) (begin etc ... (do-ec cmd)))
                ((do-ec (:do olet lbs ne1? ilet ne2? lss) cmd)
                 (do-ec:do cmd (:do olet lbs ne1? ilet ne2? lss)))
                ((do-ec (g arg1 arg ...) cmd)
                 (g (do-ec:do cmd) arg1 arg ...)))))
  (list (cons 'ec-simplify
              (syntax-rules
                (if not let begin)
                ((ec-simplify (if #t consequent)) consequent)
                ((ec-simplify (if #f consequent)) (if #f #f))
                ((ec-simplify (if #t consequent alternate)) consequent)
                ((ec-simplify (if #f consequent alternate)) alternate)
                ((ec-simplify (if (not (not test)) consequent))
                 (ec-simplify (if test consequent)))
                ((ec-simplify (if (not (not test)) consequent alternate))
                 (ec-simplify (if test consequent alternate)))
                ((ec-simplify (let () command ...))
                 (ec-simplify (begin command ...)))
                ((ec-simplify (begin command ...))
                 (ec-simplify 1 () (command ...)))
                ((ec-simplify 1 done ((begin to-do1 ...) to-do2 ...))
                 (ec-simplify 1 done (to-do1 ... to-do2 ...)))
                ((ec-simplify 1 (done ...) (to-do1 to-do ...))
                 (ec-simplify 1 (done ... to-do1) (to-do ...)))
                ((ec-simplify 1 () ()) (if #f #f))
                ((ec-simplify 1 (command) ()) command)
                ((ec-simplify 1 (command1 command ...) ())
                 (begin command1 command ...))
                ((ec-simplify expression) expression)))))

;; END OF FILE
