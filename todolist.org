To Do list 

Thu Mar 28 12:30:17 EDT 2019
-------------------------------------------------------------------
* hardware
http://mypage.iu.edu/~dsurma/courses/C335/Spr-19/www/c335.html
** hw
*** watch last video posted
*** hw7 (4/2)
*** read ch2-4.4
** optional
*** read
*** mips emulator
it turns out that spim is an interpreter, and a poorly made one at that
so macro expansion would mean doing something that was not part of the book' specification
and rewritting much of spim
*** read 
**** main book 
***** ch 1 ||done||
***** ch 2,3,rest
**** computer-organization-and-architecture
**** structured-computer-organization
**** macro
**** assembler
**** loader
**** virtual machine
* stats
http://pages.iu.edu/~zguan/m261/m261.htm
** hw
*** Homework 9  (3/25) ||done||
Sections 10.1-10.3 Exercise 10.1, 10.2, 10.4, 10.5, 10.6, 10.14. 
Study the textbook Examples in Sections 10.1-10.3.
*** Homework 10 (4/8)
Section 10.4 Exercise 10.19, 10.21, 10.22. 
Study the textbook Examples in Section 10.4.
*** TEST        (4/3)
*** read
**** stats book ch6-11
** optional
**** math stats book
**** graduate probability book, measure theory, etc..
*** code
**** automate selected problems
* physics
** EXAM (4/3)
** optional
*** read
**** university physics
**** structure and interpretation of mechanics
**** thermal/statistical mechanics
*** code
**** statistical mechanics with scheme
* Other:
** current plan
*** finish bs math/cs
*** finish masters pure math
**** schools to apply to
***** logic groups (search on AMS website)
University of California--Berkeley
University of California--Los Angeles
University of Notre Dame
University of Illinois--Chicago
University of Illinois--Urbana-Champaign
Carnegie Mellon University
University of Chicago
Cornell University
University of Wisconsin--Madison
***** else
****** western michigan university 
graph theory and good relationship with computer science people
****** university of florida
really big school

** jobs
*** community college professor
    Need: to finish masters degree in math at least, 
    Pro: everything stays academic, 
         actually get to understand things
    Con: It is idiots forever
*** embeded systems engineer
    An EE degree would have been much more appropriate
    Pro: Knuth style coding, robots!
    Con: Expensive to train skills
*** data/ml engineer
    Need: much more reading on the topics
    Pro: Actually important stuff going on, highest pay
    Con: stats is just applied measure theory
         AI is just an assortment of good math techniques
** education
*** general education
**** math
***** algebra 
	  external relationship of members of a set
****** 
	  language: (A, A x ... x A -> A)
	  idea: structure of sets
	  history: proving things in general aout elementary algebra
	  Can be thought of as 'structure' a set in total has, or properties of functions mapping elements of X back to elements of X
***** topology 
	  internal relationship of members of a set
****** 
	  language: (X,t) and then later (X,t) -> (Y,k)
	  idea: relationships between set elements of a given set
	  history: understanding how objects relate to each other, spacially or by connectedness
	  Can be thought of the spacial relationship of stuff, or how 'close' one thing is to another
	  the internal relationship is not just 'topology' though it can also be about a metric, or uniformity
***** analysis 
	  functions
****** 
	  language: X -> X
	  idea: functions of sets
	  history: closing plot holes in calculus
	  The typical starting point is using a set with a defined algebra and topology (real numbers) 
	  fun stuff to do is to find areas sectioned by functions, smoothness of functions, rate of change of functions, 
	  connectedness of functions, measures of area functions, convergence rates of functions.
*** focus
**** model theory
*** for fun
**** physics
***** mechanics
****** classical
****** relatistic
****** quantum
****** statistical
***** electrodynamics
** class schedule
*** spring 
CSCI-C 335 Computer structures
MATH-M 261 Statistical Inferences
PHYS-P 221 Physics 1
*** summer
*** fall
algebra 2 (self study)
33449 applied deep learning CSCI-C  490 (first choice)
**** optional
33458 applied data mining CSCI-C  490 (sounds trivial but lucrative)
german (online from another campus/test out)
*** spring
CSCI-C 311 Programming Language Theory
CSCI-C 421 Digital Design
CSCI-C 435 Operating Systems
INFO-I 202 CS gen ed

** internship
first source bank software internship, 

ash
aws classes
graduated 2017
took 2 months to get interviews

website of first source has intership application
Ramman also has their info

** notes
*** mathematicians I like
David Hilbert
Von Neumann
Church
Turing
Gottlob Frege
Bertrand Russell 
*** kind of dislike
Newton
Einstein
Erdos
Feyman
*** math
nxm * mxp = nxp

In the beginning, I had no idea what was going on. We had always briefly recapped set theory and its overlaps with other subjects in courses, but this was something else. Rings, fields, groups, morphisms, all kinds of stuff. The proofs were often throwing around so many terms that I had to look them up, then look up the terms used in those terms. The proofs could be so compressed. It was hard, it was interesting, and I just felt like there was something there.

In analysis, it seems very clear what's going on. Building up sequences, series, defining things like limits, to be able to learn the theory and then also practically use tools in analysis to differentiate, integrate, solve differential equations and so on. It felt more like a tool kit for practical mathematics and physics. Even higher analysis of multiple variables, manifolds, or complex analysis seemed like that (although I do make an exception for Riemann geometry, I really loved that).

After university, I went on living my life as people do. Often working in fields that didn't really require most of what I learned.

But one day, I came across something that required some good mathematical structures. I pulled out my group theory stuff, got into algebraic lattices, all kinds of stuff, and ended up somehow getting lost in category theory. That was about 4 years ago. Honestly, I work on this stuff regularly since then. There is something so rewarding about the study of these structures.

It makes me feel like I'm learning how to think better, learning how to identify and think in structures, abstraction, and logic so much better. I try to approach problems less like someone who does analysis and wants to calculate an answer, and more as someone who is looking to classify the most abstract structure that groups together what I'm looking at with other things and then apply the most basic logical conclusions to figure something out for much more than what I originally saw in front of me.

It even got me deeper into philosophy through logics and constructivism.

This is just my opinion, and I'm sure if one of my favorite professors from uni who was specialized in analysis would read this, he would greatly disagree, but it just makes me feel happy to do this. I don't need to do it to solve a problem set, pass an exam, or even as a job, I just do it out of curiosity. I don't think many topics in analysis could hold my attention like that.

So give it a try. See what you think. I hope you can also find the beauty in abstract structures.
I don't believe what I'm doing is especially active or popular (so hopefully someone else will respond with a better answer), but seeing as no one has answered yet, I'll just mention one of the things algebraists do: invent new algebras.

The process is very easy to describe. It may or may not result in something useful. Take a set A and define a set F of operations on A (maps from An into A, for various non-negative integer values of n). The set A plus the operations F is what we call an algebra, usually denoted A=⟨A,F⟩. The algebras you already know (e.g., groups, rings, modules) are examples.

In my work, I think about different ways to construct such algebras. Usually I work with finite algebras, often using computer software like GAP or the Universal Algebra Calculator to construct examples and study them. I look at the important features of the algebras and try to understand them better and make general statements about them.

To address your last question, there is the following open problem that I worked on as a graduate student: Given a finite lattice L, does there exist a finite algebra A (as described above) such that L is the congruence lattice of A. This question is at least 50 years old and quite important for our understanding of finite algebras. In 1980 it was discovered (by Palfy and Pudlak) to be equivalent to the following open problem about finite groups: given a finite lattice L, can we always find a finite group that has L as an interval in its subgroup lattice? Imho, these are fun problems to work on.

---

A pure ring theorist will often have thought quite a bit about Kothe's conjecture. They will have thought about stuff that has the morpheme "nil" in it. Is the polynomial ring of a nil ring nil? Nilpotent maybe? When you hear these theorems and problems for the first time in a single talk, you might have trouble distinguishing between open questions and solved or even trivial problems soon after that. They all sound rather similar. In general, there are loads of simple-sounding problems like Kothe's conjecture in ring theory that are difficult. Many of them have probably never been asked.

Some of ring theorists, I believe these are mainly from Iran, will have considered some kind of graph defined by ring-theoretic stuff. Take a ring and call the zero divisors vertices. Throw in an edge between x and y whenever xy=0. You get a graph that you can do all kinds of things with. You can ask which rings induce a graph with this or that property.

Often a noncommutative ring theorist will be looking for some kinds of left-right symmetries. If you define a left Xical ring-theoretic thing and a right Xical ring-theoretic thing, are they the same ring-theoretic thing? The Jacobson radical may have been the inspiration for this.

Another thing is that, as in a lot of mathematics, algebraists will be trying to classify their objets. Rings in general don't seem reasonably classifiable, which leaves room for attempts at partial classification. In ring/algebra theory these will often aim at generalizing Wedderburn's theorem.

This is a very narrow part of what algebraists do. Algebra comes in so many flavors. The commutative-noncommutative boundary is especially strong I think. Also, some algebraists will think a lot about universal algebra, varieties and pseudo-varieties, some won't. Some will be deeply in love in categories, some will say meh.

*** advice on C 

I don't know what you mean by “master C”, but if you want
to get better at it, just do it. Make programs, have some ideas that
fit your non-programming skills and produce a shitload of code to
support things you think are fun. 

I'm doing C now since at least ‘88, that's almost 30 years, I think I
was able to code C in '86 already, but I have no source files left,
that are this old, after two times in my life a MS Windows destroyed
60% and 30% of all files I ever created. That was at times where we
had no backup space. So I'm not sure about that anymore. It's a lot of
time. And I still learn a new thing or ten every day. Before that it
was Assembly, Database languages, a lot of Basic that I mixed with
Assembly. Basic was a bastard language of all script languages back in
those days. It was our Lua and your SQL and our Python and our Bash
and just everything. It was the not so loved step-mother that you
could not avoid, but that you tricked and cheated so much that it was
quite cool in the end. Gambas Almost Means Basic if you want to see
yourself what it was like. Basic is like a drug. Fast, easy and gives
you quick success, illusions of being invincible and if you never
leave that you will crash hard. Great project, Gambas.

But you do not need 30 years
to master anything. If you work hard, you should be a master after ten
years of doing something, some say after six years it's possible. But
you really have to work hard for that. So, my way is this: I code a
program every day. At least one little routine and because you have to
do that for a long time, there is no sense in burning yourself
out. You have to be a steady worker, not a hayfire. I know oh so many
hayfire guys that stopped programming all together after six years or
so. Because they burned theirself or let other people burn them. We
lose at least a thousand Einsteins a day with our modern software
industry. They burn them. So, don't let them touch you. Use them, do
not get used by them. You master C in understanding where you stand
with C and see the world around you. You need to know and understand,
able to read and even to write Assembly language. It will expand your
knowledge of your machine. You need also to know about your
environment, most likely Linux. If you are still on Windows, that's
the first bridge to burn, leave that. Everything you'll learn there is
wasted time of your life. That platform is dead already. Linux isn't
perfect and there's something new every day here, but Linux has
future, it is growing, it is a kind of living organism, that you can
be part of. Windows is just a carcass for the worms. That horse in the
middle of the street isn't going to win the race. 

So, know your
platform, know Linux system calls, know the libraries, know what
additional, non-standard libraries are there, test them. And if they
are performant and well written, use them. Ncurses, SDL, Gaul, libsfm,
Qt5, dig yourself in. 

Fortify your position, because people will come
and try to get you with the one or other shitty HLL, that will take
you away with promises, like Java did with me. I should never left C
and I left it, because I didn't fortify my position. You need to have
at least a good library base at your hand to kill off all those stupid
user-level and API-level scripts with that. Only then you will stay
where you are, which is your battleground against the “easy way” that
is promised everywhere. But that way leads nowhere. 

But learn to leave
your fortress by using scripts of yourself. Learn to include Lua into
your projects and with that learn to bastardize that language and make
it your willing servant. Together you can beat the crap out of
everything out there. Lua is the perfect companion for all
configuration and data flow management outside of your project. Just
think of a spreadsheet application in C that files can include Lua
routines, using the functions you are providing. There you have that
general idea. And if you know Assembly level, which not only means
your processor but also over OpenCL your GPU level, the hardware
level, you have the perfect tool. Because C does cooperate well with
everything. If you start doing something in C++ for example, you are
bound to the shitty STL more or less and you are bound to the memory
concept of C++. Which is incompatible with all others. You'll lose the
freedom. And that's dire warning of mine about using something
different from C on your implementation level. 

Higher languages are
always API level languages. Like Lua. They just cover this under
sheets and sheets of ideology. Like Lisp is just an API level over a
list-manipulation library. Prolog an API language over a logic solver
and so on. Lua is clear and true about its nature. It doesn't play
ideology games with you. It just wants to serve and it serves
well. You need to face the world of programming outside of languages,
means you have to learn algorithms and mathematics. Without that all
your knowledge all your deep insight into the world of programming
will be worth nothing. You can learn that by the book. I always
prefered to learn it by doing. So take your time to select a small
project. Not a big one, think small. Take that project and do it. And
learn the algorithms on the way. 

Graph theory is, by the way, one of
the fields that are almost universally applicable. Every time you got
some data structure, every time you have some sort of finite state
machine inside your implementation, the graph theory does apply. It is
one of the most useful parts of “algorithms” that I ever learned to
use. Doesn't sound very practical or if you didn't touch it yet, you
might not see how far that reaches. But in principle everything you do
in a program is a graph. So know the laws of that. Really. Do not
theorize that too much, practice that instead. Go through the
algorithms of R. Sedgewick (for example here) It would be like riding
the waves of the wide ocean without a compass without that. C is the
core of everything. But it is not the only thing you need to know. It
is the fortress from where you can fight your battle, it is the point
of Archimedes where you can lever the world out of its fundament. You
can change everything from this strongpoint, but you have to be able
to move around. C is not like the other languages. It is not a
prison. It is freedom. Think “pirate!”, okay?

** Needed:
*** workout (rest when needed, and stretch)
- walk/run 10km
- 100 bench presses/pushups
- 100 situps 
- 100 squats
-- 20 curls
-- 10 overhead press
-- 10 upright row
*** meals
**** breakfast
| oatmeal, coffee       |
| egg, coffee           |
| health cereal, coffee |
| coffee                |
| nothing               | 
**** lunch
| protien shake |
| protien bar   |
| nothing       |
**** dinner
| What dad makes |
| protien shake  |
| protien bar    |

doctor appointment jun 11th 8 am 
get fall books onto computer ||done||
print insurance for car
get crimson card (6/30)
change steam account to new credit card
*** get better
**** math
***** cs
****** languages
******* scheme
        structure and inerpretation of computer programs
******* C
        C the programming language
******* python 
        Introduction-to-Computation-and-Programming-Using-Python-With-Application-to-Understanding-Data.pdf
****** ai
******* machine learning
******** deep learning
******** data analysis
****** foundation
***** physics
****** classical/modern base
****** quantum
****** electrodynamics
****** relativity
****** statistical physics
***** math logic 
homotopy type theory
****** main branches
******* proof theory
******* model theory
******* set theory
******* recursion theory 
****** (knight recommended)
      model theory: an introduction - dave marker
      recursive functions and effective computability - hartley rogers
      turing computability - bob soare
      computability theory - barry cooper
      model-theoretic work on the surreal numbers, by: 
        Berarducci, Mantova, Aschenbrenner, van den Dries, 
        van der Hoeven
      bulletin of symbolic logic

** Recommended:
*** advice on making graph theory graphs in pdf form
    I created my trees with Inkscape and saved then either as pngs or
    as eps files. Then you can incorporate them in latex with \epsfig
*** find a grad school
***** ask shaffii or savvo. and song about schools 
      I am not sure if Shafii or Savvo. still like me, but Song has always 
      been supportive. When I asked Connor he literally googled it in front 
      of me...
      I am looking for schools that match my interest and ability. 
      My primary goal is research, although I feel that my options may
      be very poor. 
      Pretty much from the start I had to deal with this crap. So whatever.

***** schools that seem interesting 
****** university of notre dame 
       top math logic school
****** university of chicago 
       top math logic school
****** university of illinois - chicago 
       top math logic school
****** university of michigan - kalamazoo
       graph theory and good connection to the cs department
*** programming:
**** these are my favorites
***** C (optimal use of algorithms/data_struct stuff)
      most of the time it does not matter, but I have a whole 
      year of c++ and raw data structures/assembly lingo. 
      So for some projects this is a fun language.
***** python (optimal use of my time for most tasks)
      was not dissapointed by this language in numerical analysis
      It is a great specification language, plus libraries large 
      and easy to use.
***** scheme (or hy{python}, guile{C}, for research code)
      best code for experiments because it gives so much freedom
      Very decentralized hacker base due to this freedom.
      This language glues itself to large libraries and languages to survive 
      hy{python}, guile{C}, clojure{java}
*** education
**** core
***** analysis 
****** foundations
******* foundationals of mathematical analysis by rudin 1/?
****** real, complex
******* Real and Complex analysis Rudin 1/396
****** functional
******* Functional Analysis Rudin 1/390
***** algebra 
****** Coding The matrix 1/512 (basic linear)
***** geometry/topology 
****** Topology Munkres 1/500
**** mixing:
****** algebraic geometry
****** differential geometry
****** algebraic topology
**** marketable skills
***** programming
****** core language
******* C
******** C Dennis Ritchie 1/250
******* python
******* lisp
******** Land of Lisp 1/460
******** scheme (guile) (interacts directly with C)
******** clojure (has infinite size data structures)
****** flavor:
******* bash (common linux language)
******** Wicked Cool Shell Scripts 10/350 
******* perl (quick implementation/string manipulator)
******* R (Good for statistics/data-mining)
***** math related
****** human languages helpful in math research
******* german (I find the most useful)
******* french (probably what is actually most common)
******* russian
******* japanese
******* chinese
**** research topics
***** Artifitial intelligence Russel 1/1060
*** books to read:
**** math
***** graph theory
***** Number Theory Rosen 1/600
***** Discrete math book Rosen 185/850
***** Coding The matrix 1/512
***** tao analysis book 8/305
***** tao analysis second book 1/211
***** counterexamples in analysis 1/180
***** how to think about analysis 1/222
***** the numerical analysis book from class
**** CS
***** Linux 2nd ed Sobell 218/890 (book from a spring class)
***** Linux 3rd ed Sobell 1/1000 (read much of 2nd ed)
**** assembly (1 to 1 to computer instructions)
***** use ARM assembly videos to build a set of notes
***** x86-64 gas assembly
***** ARM assembly book 26/161
***** Lisp book 114/587 ?
***** data structures book 13/688
**** other
***** how buildings learn
***** mere christianity by cs lewis


functools.partial(<function lambdaSumv.<locals>.ftotal at 0x7f5de2ba2e18>, [functools.partial(<function bezier.<locals>.<lambda> at 0x7f5de2cbcf28>, 1), functools.partial(<function bezier.<locals>.<lambda> at 0x7f5de2cbcf28>, 2), functools.partial(<function bezier.<locals>.<lambda> at 0x7f5de2cbcf28>, 3)])
** logic
**** introduction to the foundations of mathematics by Wilder
**** All of Dr. Knights recommendations
**** principa mathematica
**** zfc book
**** category theory
**** type theories
** algebra 
*** read algegra ch 0
ch1-4
*** hw
online listed problems
*** optional
There are places I address math. That is the strategy behind
Eigenvalues the best I can tell. While it may have some utility in
many contexts, in terms of stretching for comprehension there is
obviously something inadequate about this approach. There are other
domains where axiomatizing may have a more sustainable interface, less
scaffold-like. Math is something metaphysical with the potential to
point to or pursue quantum and probably morphic realms as well.


