To Do list 

Sun May  5 21:51:37 EDT 2019
"Actions that cause harm are a crime. Actions that cause no harm are one's own business" - silver dragon motto dnd
-----------------------------------------------------------------
* fall
** algebra
*** books
**** main book (Dummit and Foote)
**** category theoretic
**** linear algebra focus
**** as reference
** deep learning
*** books
**** deep learning with python
** data science
nothing stands out for this intro, bombast statistics and ai 
** german
doulingo
read german
* spring
** programing languages
*** denotational semantics and programming language book
** OS
*** dinosaur book
** digital design
*** digital design kit
** info 202
I give no shits about this class

* other
** current plan
*** finish bs math/cs
*** finish masters pure math
**** schools to apply to
***** logic groups (search on AMS website)
University of California--Berkeley
University of California--Los Angeles
University of Notre Dame
University of Illinois--Chicago
University of Illinois--Urbana-Champaign
Carnegie Mellon University
University of Chicago
Cornell University
University of Wisconsin--Madison
***** else
****** western michigan university 
graph theory and good relationship with computer science people
****** university of florida
really big school

*** focus
**** model theory
** class schedule
*** fall
algebra 2 (self study)
33449 applied deep learning CSCI-C  490 (first choice)
**** optional
33458 applied data mining CSCI-C  490 (sounds trivial but lucrative)
german 150 
*** spring
CSCI-C 311 Programming Language Theory
CSCI-C 421 Digital Design
CSCI-C 435 Operating Systems
INFO-I 202 CS gen ed
** notes
*** math
In the beginning, I had no idea what was going on. We had always briefly
recapped set theory and its overlaps with other subjects in courses, but this
was something else. Rings, fields, groups, morphisms, all kinds of stuff. The
proofs were often throwing around so many terms that I had to look them up,
then look up the terms used in those terms. The proofs could be so compressed.
It was hard, it was interesting, and I just felt like there was something
there. In analysis, it seems very clear what's going on. Building up sequences,
series, defining things like limits, to be able to learn the theory and then
also practically use tools in analysis to differentiate, integrate, solve
differential equations and so on. It felt more like a tool kit for practical
mathematics and physics. Even higher analysis of multiple variables, manifolds,
or complex analysis seemed like that (although I do make an exception for
Riemann geometry, I really loved that). After university, I went on living my
life as people do. Often working in fields that didn't really require most of
what I learned. But one day, I came across something that required some good
mathematical structures. I pulled out my group theory stuff, got into algebraic
lattices, all kinds of stuff, and ended up somehow getting lost in category
theory. That was about 4 years ago. Honestly, I work on this stuff regularly
since then. There is something so rewarding about the study of these
structures. 

It makes me feel like I'm learning how to think better, learning how
to identify and think in structures, abstraction, and logic so much
better. I try to approach problems less like someone who does analysis
and wants to calculate an answer, and more as someone who is looking
to classify the most abstract structure that groups together what I'm
looking at with other things and then apply the most basic logical
conclusions to figure something out for much more than what I
originally saw in front of me. It even got me deeper into philosophy
through logics and constructivism. This is just my opinion, and I'm
sure if one of my favorite professors from uni who was specialized in
analysis would read this, he would greatly disagree, but it just makes
me feel happy to do this. I don't need to do it to solve a problem
set, pass an exam, or even as a job, I just do it out of curiosity. I
don't think many topics in analysis could hold my attention like
that. So give it a try. See what you think. I hope you can also find
the beauty in abstract structures. I don't believe what I'm doing is
especially active or popular (so hopefully someone else will respond
with a better answer), but seeing as no one has answered yet, I'll
just mention one of the things algebraists do: invent new
algebras. The process is very easy to describe. It may or may not
result in something useful. Take a set A and define a set F of
operations on A (maps from An into A, for various non-negative integer
values of n). The set A plus the operations F is what we call an
algebra, usually denoted A=⟨A,F⟩. The algebras you already know (e.g.,
groups, rings, modules) are examples. In my work, I think about
different ways to construct such algebras. Usually I work with finite
algebras, often using computer software like GAP or the Universal
Algebra Calculator to construct examples and study them. I look at the
important features of the algebras and try to understand them better
and make general statements about them. To address your last question,
there is the following open problem that I worked on as a graduate
student: Given a finite lattice L, does there exist a finite algebra A
(as described above) such that L is the congruence lattice of A. This
question is at least 50 years old and quite important for our
understanding of finite algebras. In 1980 it was discovered (by Palfy
and Pudlak) to be equivalent to the following open problem about
finite groups: given a finite lattice L, can we always find a finite
group that has L as an interval in its subgroup lattice? Imho, these
are fun problems to work on.

---

A pure ring theorist will often have thought quite a bit about Kothe's
conjecture. They will have thought about stuff that has the morpheme
"nil" in it. Is the polynomial ring of a nil ring nil? Nilpotent
maybe? When you hear these theorems and problems for the first time in
a single talk, you might have trouble distinguishing between open
questions and solved or even trivial problems soon after that. They
all sound rather similar. In general, there are loads of
simple-sounding problems like Kothe's conjecture in ring theory that
are difficult. Many of them have probably never been asked.

Some of ring theorists, I believe these are mainly from Iran, will
have considered some kind of graph defined by ring-theoretic
stuff. Take a ring and call the zero divisors vertices. Throw in an
edge between x and y whenever xy=0. You get a graph that you can do
all kinds of things with. You can ask which rings induce a graph with
this or that property.

Often a noncommutative ring theorist will be looking for some kinds of
left-right symmetries. If you define a left Xical ring-theoretic thing
and a right Xical ring-theoretic thing, are they the same
ring-theoretic thing? The Jacobson radical may have been the
inspiration for this.

Another thing is that, as in a lot of mathematics, algebraists will be
trying to classify their objets. Rings in general don't seem
reasonably classifiable, which leaves room for attempts at partial
classification. In ring/algebra theory these will often aim at
generalizing Wedderburn's theorem.

This is a very narrow part of what algebraists do. Algebra comes in so
many flavors. The commutative-noncommutative boundary is especially
strong I think. Also, some algebraists will think a lot about
universal algebra, varieties and pseudo-varieties, some won't. Some
will be deeply in love in categories, some will say meh.

*** advice on C 

I don't know what you mean by “master C”, but if you want
to get better at it, just do it. Make programs, have some ideas that
fit your non-programming skills and produce a shitload of code to
support things you think are fun. 

I'm doing C now since at least ‘88, that's almost 30 years, I think I
was able to code C in '86 already, but I have no source files left,
that are this old, after two times in my life a MS Windows destroyed
60% and 30% of all files I ever created. That was at times where we
had no backup space. So I'm not sure about that anymore. It's a lot of
time. And I still learn a new thing or ten every day. Before that it
was Assembly, Database languages, a lot of Basic that I mixed with
Assembly. Basic was a bastard language of all script languages back in
those days. It was our Lua and your SQL and our Python and our Bash
and just everything. It was the not so loved step-mother that you
could not avoid, but that you tricked and cheated so much that it was
quite cool in the end. Gambas Almost Means Basic if you want to see
yourself what it was like. Basic is like a drug. Fast, easy and gives
you quick success, illusions of being invincible and if you never
leave that you will crash hard. Great project, Gambas.

But you do not need 30 years
to master anything. If you work hard, you should be a master after ten
years of doing something, some say after six years it's possible. But
you really have to work hard for that. So, my way is this: I code a
program every day. At least one little routine and because you have to
do that for a long time, there is no sense in burning yourself
out. You have to be a steady worker, not a hayfire. I know oh so many
hayfire guys that stopped programming all together after six years or
so. Because they burned theirself or let other people burn them. We
lose at least a thousand Einsteins a day with our modern software
industry. They burn them. So, don't let them touch you. Use them, do
not get used by them. You master C in understanding where you stand
with C and see the world around you. You need to know and understand,
able to read and even to write Assembly language. It will expand your
knowledge of your machine. You need also to know about your
environment, most likely Linux. If you are still on Windows, that's
the first bridge to burn, leave that. Everything you'll learn there is
wasted time of your life. That platform is dead already. Linux isn't
perfect and there's something new every day here, but Linux has
future, it is growing, it is a kind of living organism, that you can
be part of. Windows is just a carcass for the worms. That horse in the
middle of the street isn't going to win the race. 

So, know your
platform, know Linux system calls, know the libraries, know what
additional, non-standard libraries are there, test them. And if they
are performant and well written, use them. Ncurses, SDL, Gaul, libsfm,
Qt5, dig yourself in. 

Fortify your position, because people will come
and try to get you with the one or other shitty HLL, that will take
you away with promises, like Java did with me. I should never left C
and I left it, because I didn't fortify my position. You need to have
at least a good library base at your hand to kill off all those stupid
user-level and API-level scripts with that. Only then you will stay
where you are, which is your battleground against the “easy way” that
is promised everywhere. But that way leads nowhere. 

But learn to leave
your fortress by using scripts of yourself. Learn to include Lua into
your projects and with that learn to bastardize that language and make
it your willing servant. Together you can beat the crap out of
everything out there. Lua is the perfect companion for all
configuration and data flow management outside of your project. Just
think of a spreadsheet application in C that files can include Lua
routines, using the functions you are providing. There you have that
general idea. And if you know Assembly level, which not only means
your processor but also over OpenCL your GPU level, the hardware
level, you have the perfect tool. Because C does cooperate well with
everything. If you start doing something in C++ for example, you are
bound to the shitty STL more or less and you are bound to the memory
concept of C++. Which is incompatible with all others. You'll lose the
freedom. And that's dire warning of mine about using something
different from C on your implementation level. 

Higher languages are
always API level languages. Like Lua. They just cover this under
sheets and sheets of ideology. Like Lisp is just an API level over a
list-manipulation library. Prolog an API language over a logic solver
and so on. Lua is clear and true about its nature. It doesn't play
ideology games with you. It just wants to serve and it serves
well. You need to face the world of programming outside of languages,
means you have to learn algorithms and mathematics. Without that all
your knowledge all your deep insight into the world of programming
will be worth nothing. You can learn that by the book. I always
prefered to learn it by doing. So take your time to select a small
project. Not a big one, think small. Take that project and do it. And
learn the algorithms on the way. 

Graph theory is, by the way, one of
the fields that are almost universally applicable. Every time you got
some data structure, every time you have some sort of finite state
machine inside your implementation, the graph theory does apply. It is
one of the most useful parts of “algorithms” that I ever learned to
use. Doesn't sound very practical or if you didn't touch it yet, you
might not see how far that reaches. But in principle everything you do
in a program is a graph. So know the laws of that. Really. Do not
theorize that too much, practice that instead. Go through the
algorithms of R. Sedgewick (for example here) It would be like riding
the waves of the wide ocean without a compass without that. C is the
core of everything. But it is not the only thing you need to know. It
is the fortress from where you can fight your battle, it is the point
of Archimedes where you can lever the world out of its fundament. You
can change everything from this strongpoint, but you have to be able
to move around. C is not like the other languages. It is not a
prison. It is freedom. Think “pirate!”, okay?

** 
doctor appointment jun 11th 8 am 
print insurance for car
get crimson card (6/30)
change steam account to new credit card
****** (knight recommended)
      model theory: an introduction - dave marker
      recursive functions and effective computability - hartley rogers
      turing computability - bob soare
      computability theory - barry cooper
      model-theoretic work on the surreal numbers, by: 
        Berarducci, Mantova, Aschenbrenner, van den Dries, 
        van der Hoeven
      bulletin of symbolic logic

** Recommended:
*** advice on making graph theory graphs in pdf form
    I created my trees with Inkscape and saved then either as pngs or
    as eps files. Then you can incorporate them in latex with \epsfig
***** ask shaffii or savvo. and song about schools 
      I am not sure if Shafii or Savvo. still like me, but Song has always 
      been supportive. When I asked Connor he literally googled it in front 
      of me...
      Pretty much from the start I had to deal with this crap. So whatever.

******* bash (common linux language)
******** Wicked Cool Shell Scripts 10/350 
***** Discrete math book Rosen 185/850
***** tao analysis book 8/305
***** Linux 2nd ed Sobell 218/890 (book from a spring class)
***** ARM assembly book 26/161
***** Lisp book 114/587 ?
***** data structures book 13/688
** logic
**** introduction to the foundations of mathematics by Wilder
**** All of Dr. Knights recommendations
**** principa mathematica
**** zfc book
**** category theory
**** type theories
** algebra 
*** read algegra ch 0
ch1-4
*** hw
online listed problems
*** optional
There are places I address math. That is the strategy behind
Eigenvalues the best I can tell. While it may have some utility in
many contexts, in terms of stretching for comprehension there is
obviously something inadequate about this approach. There are other
domains where axiomatizing may have a more sustainable interface, less
scaffold-like. Math is something metaphysical with the potential to
point to or pursue quantum and probably morphic realms as well.
“Ramanujan, they call you genius”. Ramanujan retorted “What? me, a genius? Look at my elbow, it will tell you the story”.
 “Night and day I do my calculations on slate. It is time consuming to look for a rag to wipe it with. I wipe the slate almost every few minutes with my elbow. I suppose my elbow is making a genius of me.”

so math masters...
why? because I have a hunch that stuff in the pure field is well structured and useful.

I really do seem to have a love for it..
I am for promoting math and thought in general, not sure what role that gives me in society

** algebra (books of)
main: dummit and foote
computational
category theory
from linear algebra 
reference (lang)
recommended for skill building 
